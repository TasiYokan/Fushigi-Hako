<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="graphics,shader,game,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="简介Interior Mapping主要用于在物体表面利用透视错局模拟出格子结构的内部内容。虽然从外部观察起来，物体内部的构造是“真实的”，但一切渲染都没有依靠更多的模型或真实顶点。这在渲染大量模式化的内部结构中会有很大作用。例如渲染高楼林立的都市时，如果要渲染每个单独的房间就会有大量的性能开销，完全的使用单一的贴图又会有些单调，这个时候就适合用Interior Mapping来伪造出建筑的外观">
<meta name="keywords" content="graphics,shader,game">
<meta property="og:type" content="article">
<meta property="og:title" content="大规模建筑内景的渲染：Interior-Mapping">
<meta property="og:url" content="http://yoursite.com/2019/09/14/implementation-of-interior-mapping/index.html">
<meta property="og:site_name" content="不思議な箱">
<meta property="og:description" content="简介Interior Mapping主要用于在物体表面利用透视错局模拟出格子结构的内部内容。虽然从外部观察起来，物体内部的构造是“真实的”，但一切渲染都没有依靠更多的模型或真实顶点。这在渲染大量模式化的内部结构中会有很大作用。例如渲染高楼林立的都市时，如果要渲染每个单独的房间就会有大量的性能开销，完全的使用单一的贴图又会有些单调，这个时候就适合用Interior Mapping来伪造出建筑的外观">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.0_cover.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.1_basic_idea.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/0.2_conventions.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.0_without_wall_thickness.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.1_wrong_wall.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.2_xy_bool_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.3_all_bool_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.4_correct_wall.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.5_wrong_sphere.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.6_wrong_sphere_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.7_wrong_sphere_mask_top.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.8_correct_sphere_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.9_potential_visual_bug.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.1_view_different_angle.gif">
<meta property="og:image" content="https://public-covers-1259535704.cos.ap-guangzhou.myqcloud.com/3.2_dirs_sprites.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/camera-space.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/perspective_correct_texture_mapping.jpg">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/ndc.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.3_unity_matrix.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.4_rotate_first_billboard.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.5_static_scale.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.6_uv_correction.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.7_perspective_correct.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.8_tiled_billboard.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.9_align_to_anchor.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.10_compare_with_real_billboard.gif">
<meta property="og:image" content="https://4.bp.blogspot.com/-fjxkTPOjjFY/W6YYGka4GeI/AAAAAAAAHZM/Z3cqOgvNANY76Ho3-_B81p1ZdmHa2j2DwCLcBGAs/s1600/Interior%2BMapping%2B-%2BFurniture.jpg">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.11_final_result.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_wrong_corner_spider_man.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_correct_corner.png">
<meta property="og:image" content="https://forum.unity.com/attachments/interiormapping-cubemap-jpg.198474/">
<meta property="og:updated_time" content="2019-10-19T03:23:54.980Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大规模建筑内景的渲染：Interior-Mapping">
<meta name="twitter:description" content="简介Interior Mapping主要用于在物体表面利用透视错局模拟出格子结构的内部内容。虽然从外部观察起来，物体内部的构造是“真实的”，但一切渲染都没有依靠更多的模型或真实顶点。这在渲染大量模式化的内部结构中会有很大作用。例如渲染高楼林立的都市时，如果要渲染每个单独的房间就会有大量的性能开销，完全的使用单一的贴图又会有些单调，这个时候就适合用Interior Mapping来伪造出建筑的外观">
<meta name="twitter:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.0_cover.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/14/implementation-of-interior-mapping/">





  <title>大规模建筑内景的渲染：Interior-Mapping | 不思議な箱</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不思議な箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        <li class="menu-item menu-item-lang">
          <a href="/en/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-language"></i> <br>
            
            中文 -> EN
          </a>
        </li>
        
      
        
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
        
      
        
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
        
      
        
        
      
      <!-- 
      <li class="menu-item menu-item-home">
        <a href="/" rel="section">
          
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
          
          首页
        </a>
      </li> -->

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  

  

  <div class="site-author" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="tasiYokan">
    <p class="site-author-name" itemprop="name">tasiYokan</p>
      
        <p class="site-description motion-element" itemprop="description"></p>
    
  </div>

  <nav class="site-state">
    
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        <a href="/categories/index.html">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        <a href="/tags/index.html">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <p></p>

  

  


</nav>


<script type="text/javascript">
    // Wait for the page to load first
    var _prevOnload = window.onload;
    var swithlang = function ()  {
        // var switchLang = document.getElementById("menu").getElementsByClassName("menu-item-switch_lang")[0].childNodes[0];
        var href = window.location.href;
        var menu = document.getElementById("menu");
        var switchLang = menu.getElementsByClassName("menu-item-lang")[0].getElementsByTagName("a")[0];

        var indexOfEn = href.toLowerCase().indexOf('/en/');
        if (indexOfEn !== -1) {
            // console.log("switch to cn from "+ switchLang.href );
            switchLang.href = href.replace('/en/', '/');
        }
        else {
            // console.log("switch to en from " + switchLang.href );
            switchLang.href = href.replace(/(^http[s]?:\/\/[a-z0-9.]*[:?0-9-]*[a-z0-9.]*\/)(.*)/i, '$1en/$2');
        }
        // console.log("href now is " + switchLang.href);
    }

    // Switch directly as the load may take a while
    // swithlang();

    window.onmousedown = function() {
        swithlang();
    }
</script>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <div class="post-inner">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/14/implementation-of-interior-mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tasiYokan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不思議な箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">大规模建筑内景的渲染：Interior-Mapping</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T22:28:30+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dev/" itemprop="url" rel="index">
                    <span itemprop="name">Dev</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
              <i class="fa fa-eye"></i>
            </span>
            
              <span class="post-meta-item-text">浏览量</span>
            
            <span class="page-pv">
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
         <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.0_cover.png" alt title="最终的效果图">
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Interior Mapping主要用于在物体表面利用透视错局模拟出格子结构的内部内容。虽然从外部观察起来，物体内部的构造是“真实的”，但一切渲染都没有依靠更多的模型或真实顶点。这在渲染大量模式化的内部结构中会有很大作用。<br>例如渲染高楼林立的都市时，如果要渲染每个单独的房间就会有大量的性能开销，完全的使用单一的贴图又会有些单调，这个时候就适合用Interior Mapping来伪造出建筑的外观而不让性能下降太多。<br>它的几个优点：<br>1.房间的数量不会影响framerate或内存开销<br>2.并不需要太多的额外资源就可以表现大的场景<br>3.实现上并不要求高级的shader model特性<br><a id="more"></a></p>
<h1 id="基本思路的实现"><a href="#基本思路的实现" class="headerlink" title="基本思路的实现"></a>基本思路的实现</h1><p>思路可以参考Joost van Dongen的论文<a href="https://pdfs.semanticscholar.org/8622/48de620efe27705af3702ab2a2c0d4ec76ec.pdf" target="_blank" rel="noopener">Interior Mapping - A new technique for rendering realistic buildings</a><br>按照Joost论文中的思路实现即可，本文不再详述。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.1_basic_idea.png" alt title="论文中的图示和下面代码的对应关系"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reciprocal of each floor's height d</span></span><br><span class="line">float3 invert_d = _Tiling / _BoundarySize;</span><br><span class="line"></span><br><span class="line">float3 cameraPos_obj = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">float3 cameraToPixelOffset_obj = i.pos_obj - cameraPos_obj;</span><br><span class="line"></span><br><span class="line">float3 cameraStepDir_obj = step(float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cameraToPixelOffset_obj);</span><br><span class="line">float3 floorId = <span class="built_in">floor</span>(i.pos_obj * <span class="number">0.999</span> * invert_d)  + cameraStepDir_obj;</span><br><span class="line">float3 floorPos_obj = floorId / invert_d;</span><br><span class="line">float3 cameraToFloorIntersectionOffset_obj = floorPos_obj - cameraPos_obj;</span><br><span class="line"><span class="comment">// This is the ratio between the actual distance before reaching destination and the distance of pixel and camera in object space</span></span><br><span class="line">float3 ratio = cameraToFloorIntersectionOffset_obj / cameraToPixelOffset_obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here the intersection coordinate has been normalized through dividing by d</span></span><br><span class="line">float2 intersectionXY_obj = (cameraPos_obj + ratio.z * cameraToPixelOffset_obj).xy * invert_d;</span><br><span class="line">float2 intersectionXZ_obj = (cameraPos_obj + ratio.y * cameraToPixelOffset_obj).xz * invert_d;</span><br><span class="line">float2 intersectionZY_obj = (cameraPos_obj + ratio.x * cameraToPixelOffset_obj).zy * invert_d;</span><br><span class="line"></span><br><span class="line">float4 ceilingCol = tex2D(_CeilingTexture, intersectionXZ_obj);</span><br><span class="line">float4 floorCol = tex2D(_FloorTexture, intersectionXZ_obj);</span><br><span class="line">float4 horizonCol = lerp(floorCol, ceilingCol, step(<span class="number">0</span>, cameraToPixelOffset_obj.y));</span><br><span class="line"></span><br><span class="line">float4 wallXYCol = tex2D(_WallXYTexture, intersectionXY_obj);</span><br><span class="line">float4 wallZYCol = tex2D(_WallZYTexture, intersectionZY_obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check which face is closer to camera and pick it as the final texuture for specific pixel</span></span><br><span class="line"><span class="keyword">float</span> xLessThanZ = step(ratio.x, ratio.z);</span><br><span class="line">float4 verticalCol = lerp(wallXYCol, wallZYCol, xLessThanZ);</span><br><span class="line"><span class="keyword">float</span> ratioMin_x_z = lerp(ratio.z, ratio.x, xLessThanZ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x_zLessThanY = step(ratioMin_x_z, ratio.y);</span><br><span class="line">float4 innerCol = lerp(horizonCol, verticalCol, x_zLessThanY);</span><br></pre></td></tr></table></figure></p>
<p>这段按照论文思路实现的代码有几点缺陷：<br>1.墙面还没有厚度，虽然可以手动加一个外墙的mask但是，会从窗外看到一个不对齐的地面，同时也无法只通过一个厚度参数自动调整。<br>2.还没有加上sprite层（家具层）丰富室内内容<br>3.在拐角处会看到本不应该看到的墙面</p>
<p>本文的一些定义：<br>Block: 每个单独的房间称为一个Block<br>内腔：每个Block中不被墙体填充的部分<br>d: 代表一个Block某个方向上的长度<br>_BoundarySize: 指一个Cube Mesh的某条棱的长度<br>_Tiling: 指在某个坐标轴方向上，Mesh被切分的次数<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/0.2_conventions.png" alt title="本文中出现的一些变量图示"></p>
<h1 id="可配置厚度墙面的实现"><a href="#可配置厚度墙面的实现" class="headerlink" title="可配置厚度墙面的实现"></a>可配置厚度墙面的实现</h1><p>如果没有显示出墙的厚度，会有看上去错位的地板<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.0_without_wall_thickness.png" alt title="图片来源[6]"></p>
<p>我们要做的是将原本的墙面朝着某个方向推出一定距离，模拟出墙的厚度。首先计算出摄像机相关变量，方便后面确定偏移量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 cameraPos_obj = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">float3 cameraToPixelOffset_obj = i.pos_obj - cameraPos_obj;</span><br><span class="line">float3 cameraStepDir_obj = step(float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cameraToPixelOffset_obj); <span class="comment">// return 1 if it's positive, otherwise 0</span></span><br></pre></td></tr></table></figure></p>
<p>原始的墙面界面位置为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">floor</span>(i.positionCopy * <span class="number">0.999</span> / _d)  + stepDir</span><br></pre></td></tr></table></figure></p>
<p>为了模拟墙面向内intrude，需要减去一个墙面的偏移量<code>(stepDir - float3(0.5, 0.5, 0.5)) * _WallThickness</code>之后再计算相似三角形边的比<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 ratio = ((<span class="built_in">floor</span>(i.positionCopy * <span class="number">0.999</span> / _d)  + stepDir - (stepDir - float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)) * _WallThickness) * _d  - cameraPos_obj) / direction;</span><br></pre></td></tr></table></figure></p>
<p>不过目前为止只是加上了一个墙面的偏移量，结果如下图一样<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.1_wrong_wall.png" alt title="本该被挡住的地方因为显示了出来，会呈现错误的透视感觉"></div><br>造成视觉上的怪异的原因是对于墙面部分，我们俯视它时依然会“穿过”水平墙面看到内部的垂直墙面，而这些uv之外的部分实际不应该被看到。</p>
<h2 id="判断像素是否在墙内"><a href="#判断像素是否在墙内" class="headerlink" title="判断像素是否在墙内"></a>判断像素是否在墙内</h2><p>找到问题之后，我们就需要找到每个block中，那些像素对应的是墙面上的位置。<br>首先利用floor可以找到每个block的中心位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 floorId = <span class="built_in">floor</span>(i.vertexPos  * <span class="number">0.999</span> / _d);</span><br><span class="line">float3 centerPos_obj = (floorId + <span class="number">0.5</span>) * _d;</span><br><span class="line">float3 offsetFromCenter_obj = <span class="built_in">abs</span>(i.vertexPos - centerPos_obj) / _d;</span><br></pre></td></tr></table></figure></p>
<p>这里的centerPos_obj在object space中，offsetFromCenter_obj表示的是归一化后的偏移，即范围为[0,1]，代表偏移量占每个block的比例.</p>
<p>至于如何判定一个点是否处在墙面里，一种方法是：<br>检测在某个平面上最远的坐标分量是否超出了内cube的半径，以xy平面为例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> max_xy = max(offsetFromCenter_obj.x, offsetFromCenter_obj.y);</span><br><span class="line"><span class="keyword">float</span> mask = step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_xy );</span><br></pre></td></tr></table></figure></p>
<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.2_xy_bool_mask.png" alt title></div><br>同样的手法可以用到其他2个平面上，合起来就是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> max_xy = max(offsetFromCenter_obj.x, offsetFromCenter_obj.y);</span><br><span class="line"><span class="keyword">float</span> mask = step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_xy );</span><br><span class="line"><span class="keyword">float</span> max_xz = max(offsetFromCenter_obj.x, offsetFromCenter_obj.z);</span><br><span class="line">mask *= step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_xz );</span><br><span class="line"><span class="keyword">float</span> max_yz = max(offsetFromCenter_obj.y, offsetFromCenter_obj.z);</span><br><span class="line">mask *= step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_yz );</span><br></pre></td></tr></table></figure><br><br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.3_all_bool_mask.png" alt title></div><br>这里mask相当于是一个AND布尔运算操作，只有在各个平面的投影中都属于“内部”中的像素才可以被称为真正的内腔，也就是会绘制墙面上的像素，这些像素的mask值为0.<br>这个过程可以想象成在三个正交的方向上对一个几何体做投影挖去不属于墙面的部分，最终剩下的白色部分就是我们所需要的墙面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 outerCol = tex2D(_outerWallTexture, i.uv);</span><br><span class="line">float4 finalCol = lerp(innerCol, outerCol, mask);</span><br></pre></td></tr></table></figure><br><br>最终的效果如<br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.4_correct_wall.png" alt title></div>

<h2 id="使用AND还是OR"><a href="#使用AND还是OR" class="headerlink" title="使用AND还是OR"></a>使用AND还是OR</h2><p>我们在进行投影布尔运算的时候，实际上会将内部结构中的墙体一并减去。但由于我们实际上只需要最外层的mask值，所以对于立方体来说，这样的操作不会有什么问题。但是对于球体等不规则物体来说，由于我们会看到内部的结构，所以被错误减去的墙体将会出现视觉问题。</p>
<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.5_wrong_sphere.png" alt title></div><br>如果将其mask输出，就能更容易的发现问题<br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.6_wrong_sphere_mask.png" alt title></div><br>本来是内部的墙面出现在了球面上，因为被不正确的减去了，所以本来应该有墙的地方就缺失了一块.<br>可能从正交视图的某个平面方向上看更容易理解<br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.7_wrong_sphere_mask_top.png" alt title="这里把部分xz平面上投影形成的mask用红色的框标注出来了"></div>

<p>修正这个错误的思路就是从之前的AND运算变成OR运算，只要在任意方向上超出内腔的范围，就认定为进入墙体。这从直观理解上也更容易理解。<br>值得注意的是，如果用OR运算，我们只需要判断两个方向即可。这是因为第三个方向的信息变得冗余了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> max_xy = max(offsetFromCenter_obj.x, offsetFromCenter_obj.y);</span><br><span class="line"><span class="keyword">float</span> mask = step(max_xy, (<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">float</span> max_xz = max(offsetFromCenter_obj.x, offsetFromCenter_obj.z);</span><br><span class="line">mask *= step(max_xz, (<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// float max_yz = max(offsetFromCenter_obj.y, offsetFromCenter_obj.z);</span></span><br><span class="line"><span class="comment">// mask *= step(max_yz, (1 - _WallThickness) * 0.5);</span></span><br><span class="line">mask = <span class="number">1</span> - mask;</span><br></pre></td></tr></table></figure></p>
<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.8_correct_sphere_mask.png" alt title="可以看到这次终于正确了。"></div>

<p>不过这也会带来一个潜在的问题，<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.9_potential_visual_bug.png" alt title><br>当tiling达到某个值的时候，墙面会恰好在立方体的边缘，这个时候，整个表面就被墙遮住了。我曾经想在shader中判断并自动做偏移（只有tiling为偶数的时候才会出现）不过后来还是决定暴露这个参数，让使用者自己决定合适的tiling。有趣的是，虽然这个问题造成了不少困扰，但是之前AND的操作方法是不会遇到这个问题的;)<br>解决方法：判断墙的边界是否超出mesh的边界，详见<a href="#culling_Wall">正确显示边角的遮挡</a></p>
<h1 id="制作Sprite-Layer"><a href="#制作Sprite-Layer" class="headerlink" title="制作Sprite Layer"></a>制作Sprite Layer</h1><h2 id="朴素的截面偏移层"><a href="#朴素的截面偏移层" class="headerlink" title="朴素的截面偏移层"></a>朴素的截面偏移层</h2><p>原论文中提到了制作在空房间内放置道具或者人物的思路，其实实现起来也很简单，和墙面一样是对观察深度进行一个偏移后计算交点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intrude XY wall along Z axis by 0.4 block length</span></span><br><span class="line">float3 spriteOffset_block = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.4</span>);</span><br><span class="line">float3 cameraStepDir_obj = step(float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cameraToPixelOffset_obj);</span><br><span class="line">float3 floorId = <span class="built_in">floor</span>(i.pos_obj * <span class="number">0.999</span> * invert_d) + cameraStepDir_obj;</span><br><span class="line">float3 spriteLayerRatio = ((floorId - spriteOffset_block) / invert_d  - cameraPos_obj) / cameraToPixelOffset_obj;</span><br><span class="line">float2 S_intersectionXY = (cameraPos_obj + spriteLayerRatio.z * cameraToPixelOffset_obj).xy  * invert_d;</span><br><span class="line">float2 S_intersectionZY = (cameraPos_obj + spriteLayerRatio.x * cameraToPixelOffset_obj).zy  * invert_d;</span><br><span class="line">float4 S_XYCol = tex2D(_SpriteTex, S_intersectionXY);</span><br><span class="line">float4 S_ZYCol = tex2D(_SpriteTex, S_intersectionZY);</span><br><span class="line"><span class="keyword">float</span> S_xLessThanZ = step(spriteLayerRatio.x, spriteLayerRatio.z);</span><br><span class="line">float4 S_verticalCol = lerp(S_XYCol, S_ZYCol, S_xLessThanZ);</span><br><span class="line"><span class="keyword">float</span> S_ratioMin_x_z = lerp(spriteLayerRatio.z, spriteLayerRatio.x, S_x_less_z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> ratioMin_xyz = lerp(ratio.y, ratioMin_x_z, xzLessThanY);</span><br><span class="line"><span class="comment">// To see if it's closer than the origin wall</span></span><br><span class="line"><span class="keyword">float</span> S_isLess = step(S_ratioMin_x_z, ratioMin_xyz);</span><br><span class="line"><span class="comment">// If sprite layer is closer and the alpha is greater than 0, replace old pixel of wall by sprite layer</span></span><br><span class="line">innerCol = lerp(innerCol, S_verticalCol, S_isLess * S_verticalCol.a);</span><br></pre></td></tr></table></figure>
<p>不过这种方法也会有明显的问题，就是只能从一个方向上观察室内的人物或物体，从侧面和背面都能很容易的注意到是面片这一事实。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.1_view_different_angle.gif" alt title="从各个角度观察"></p>
<h3 id="支持多方向适配"><a href="#支持多方向适配" class="headerlink" title="支持多方向适配"></a>支持多方向适配</h3><p>我们可以手工指定其他面，从而正确的显示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// If the tile's unilateral count(from the center to this tile) reach half of total tiling, means it's the side tile</span></span><br><span class="line"><span class="keyword">float</span> isSideOrFront = <span class="built_in">abs</span>(<span class="built_in">ceil</span>(i.pos_obj * <span class="number">0.999</span> * invert_d).x) / (_Tiling.x/<span class="number">2</span>) &gt; <span class="number">0.999</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"><span class="comment">// Pick the color from side texture</span></span><br><span class="line">float4 S_verticalCol = lerp(S_XYCol, S_ZYCol, isSideOrFront);</span><br><span class="line"><span class="comment">// Here we use the ratio of the face we decided to use in above step to overwrite the actual minimal one "S_x_less_z"</span></span><br><span class="line"><span class="keyword">float</span> S_ratioMin_x_z = lerp(spriteRatio.z, spriteRatio.x, isSideOrFront);</span><br><span class="line">float2 halfTileCount = lerp(S_intersectionXY_ori, S_intersectionZY_ori, isSideOrFront) / _Tiling.x * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Because our sprite will keep repeating, even in the place we should not see it. Luckily, we can use the time it repeats to see if it's out of the valid display region.</span></span><br><span class="line"><span class="keyword">bool</span> validSpriteRegion = <span class="number">1</span></span><br><span class="line">    * step(<span class="built_in">abs</span>(halfTileCount.y), <span class="number">1</span>) </span><br><span class="line">    * step(<span class="built_in">abs</span>(halfTileCount.x), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> ratioMin_xyz = lerp(ratio.y, S_ratioMin_x_z, xzLessThanY);</span><br><span class="line"><span class="keyword">float</span> S_isLess = step(S_ratioMin_x_z, ratioMin_xyz) * validSpriteRegion;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>

<p><img src="https://public-covers-1259535704.cos.ap-guangzhou.myqcloud.com/3.2_dirs_sprites.png" alt title="可以看到效果还是不理想"></p>
<h2 id="类Billboard-Sprite-Layer"><a href="#类Billboard-Sprite-Layer" class="headerlink" title="类Billboard Sprite Layer"></a>类Billboard Sprite Layer</h2><p>上面的方法除了在适应不同视角上处理的很生硬，代码中也有很多硬编码的重复代码。一个比较优雅的改进方法是使用一种技术可以自动的适应不同的观察角度。所以我在这里的方法是利用billboard思想制作一个可以自动跟随摄像机的sprite</p>
<h3 id="传统Billboard"><a href="#传统Billboard" class="headerlink" title="传统Billboard"></a>传统Billboard</h3><p>传统的billboard思路是变换顶点坐标：将Object Space下的坐标直接赋值给View Space，即可以获得稳定不变的view位置。几乎所有的操作也都是在vertex shader中完成的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4 billboardPos = mul(UNITY_MATRIX_P,</span><br><span class="line">    mul(UNITY_MATRIX_MV, float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)) <span class="comment">// 依旧要记录物体中心的位置，否则物体始终在屏幕中央</span></span><br><span class="line">    + float4(v.vertex.x, v.vertex.y, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure></p>
<p>但是显然这种方法无法运用到我们这个例子上，因为其他部分的显示要依附于原始的顶点位置，另外如果我们有多个block，那么对于每个block，我们无法再分出更多的顶点来完成变换（不会考虑Gemotry Shader)</p>
<h3 id="物体空间内的Billboard"><a href="#物体空间内的Billboard" class="headerlink" title="物体空间内的Billboard"></a>物体空间内的Billboard</h3><p>我们的思路是在保持顶点位置不变的情况下，算出每个像素对应的立方体表面的一个点的投影坐标</p>
<h3 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h3><p>在一般的渲染管线中。最先传入的顶点数据都是模型空间下的(Object space/Model space)，经过Model Matrix，View Matrix和Projection Matrix以及Viewport Transform之后成为屏幕上的坐标。在不同的文章中，Projection Matrix的定义会有差别，也是比较容易引起误导的地方。我们这里将Projection Matrix定义为将物体从View Space(Eye Space)转换到NDC Space的矩阵。<br>这样一个完整的Projection Matrix包括两个部分，<br>第一部分是“线性”的缩放，将原本的View Frustum到近裁面为$[-Z_{near}, Z_{near}]$,但深度只有1的“相似” View Frustum。在这个Clip Space中，任意一点的属性都可以由顶点属性基于x,y,z中的任意一个进行插值而得到。<br>$$<br>\left[<br>\begin{array}{cccc}<br> x_{clip}\\<br> y_{clip}\\<br> z_{clip}\\<br> 1<br>\end{array}<br>\right ]<br>=<br>\left[<br>\begin{array}{cccc}<br> \frac{ {2n} }{ {r-l} } &amp; 0 &amp; \frac{ {r+l} }{ {r-l} }  &amp; 0 \\<br> 0 &amp; \frac{ {2n} }{ {t-b} } &amp; \frac{ {t+b} }{ {t-b} }  &amp; 0 \\<br> 0 &amp; 0                      &amp; \frac{ {-(f+n)} }{ {f-n} } &amp; \frac{ {-2fn} }{ {f-n} } \\<br> 0 &amp; 0 &amp; -1 &amp; 0 \\<br>\end{array}<br>\right ]<br>\left[<br>\begin{array}{cccc}<br> x_{view}\\<br> y_{view}\\<br> z_{view}\\<br> 1<br>\end{array}<br>\right ]<br>$$<br>这一步发生在vert shader中<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/camera-space.png" alt title="图中的是Camera Space，但Clip Space也是类似的形状,。图片来自[1]"><br>第二部分中，我们要将Clip Space通过Perspective Divide转换到NDC(Normalized Device Coordinates) Space。NDC空间是按近大远小压缩的。<br>NDC还有另外一个特点：该空间中如果要计算任意一点的属性值，直接根据Barycentric Interpolation来插值的话会因为深度的非均匀压缩而产生扭曲<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/perspective_correct_texture_mapping.jpg" alt title="中间为没有透视矫正的场景，图片来自wikipedia"><br>解决方法是应用Perspective Correction进行矫正，若已知顶点P1, P2的属性，则线段上任意一点P的值为<br>$$p=z[\frac{p_1}{z_1}(1-t) + \frac{p_2}{z_2}t]$$<br>直观的理解是先将属性按照深度压缩，然后就可以线性的插值了。详细的推导过程见<a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation" target="_blank" rel="noopener">scratchapixel</a></p>
<p>Perspective Divide的矩阵表示<br>$$<br>\left[<br>\begin{array}{cccc}<br> x_{ndc}\\<br> y_{ndc}\\<br> z_{ndc}<br>\end{array}<br>\right ]<br>=<br>\left[<br>\begin{array}{cccc}<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}<br>\end{array}<br>\right ]^{\mathsf{T}}<br>\left[<br>\begin{array}{cccc}<br> x_{clip}\\<br> y_{clip}\\<br> z_{clip}<br>\end{array}<br>\right ]<br>$$<br>这一步在frag shader之前GPU自动进行<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/ndc.png" alt title="注意此时z轴的方向会变成相反的。 图片来自[1]"><br>如果将clip space中的属性应用到屏幕上，会因为顶点的位置是压缩过的而产生变形。</p>
<p>这样有了两个部分后，一个完整的Projection Matrix就可以表示为<br>$$<br>[M_{Proj}] =<br>\left[<br>\begin{array}{cccc}<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}\\<br>    N/A<br>\end{array}<br>\right ]^{\mathsf{T}}<br>\left[<br>\begin{array}{cccc}<br> \frac{ {2n} }{ {r-l} } &amp; 0 &amp; \frac{ {r+l} }{ {r-l} }  &amp; 0 \\<br> 0 &amp; \frac{ {2n} }{ {t-b} } &amp; \frac{ {t+b} }{ {t-b} }  &amp; 0 \\<br> 0 &amp; 0                      &amp; \frac{ {-(f+n)} }{ {f-n} } &amp; \frac{ {-2fn} }{ {f-n} } \\<br> 0 &amp; 0 &amp; -1 &amp; 0<br>\end{array}<br>\right ]<br>$$</p>
<p>如果直接使用frag shader的输入中的position（通过SV_POSITION这个语义绑定(semantics binding) ）的xy分量来映射billboard的uv，我们可以得到一个屏幕空间下的映射，但是使用的其实就是类似于gl_FragCoord的屏幕坐标值，并不能适应我们后面的调整需要。另外补充一下，SV_POSITION虽然在vert shader还是Clip Space，但是在进入frag shader之前会进行Perspective Divide（在某些硬件下这部分的计算会交给frag shader，但是仍处于可编程部分之前，所以可以通俗的认为都发生在frag shader之前）从而SV_POSITION就进入了NDC也即就行了透视处理。<br>虽然Unity中DirectX和OpenGL或Vulkan对projection matrix的实现各不相同，但是他们的w分量都是$Z_{view}$(虽然Projection Matrix中$w = -Z_{view}$，但在前一步的View Matrix时已经取反了一次)，所以除以这个w分量就能将坐标压缩到NDC完成透视变换。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.3_unity_matrix.png" alt title><br>屏幕空间下的值只能使用NDC来插值，Clip Space下坐标和View Space成“线性”关系，和World Space成affine关系。</p>
<p>虽然frag shader中的输入SV_POSITION的z值已经是NDC下的，但是因为我们后面会要计算相对参考点的位置，而参考点又都没有进行透视处理，所以为了方便起见，我们统一在Clip Space进行处理，最后一步的时候再转换到NDC空间。<br>而要获得像素点在Clip Space下的坐标，我们有两种方法，<br>一种是对已经进入到ndc的坐标逆向乘以w分量从而得到Clip Space坐标。不过因为SV_POSITION本身并不属于NDC，所以我们不能通过这种方法获取除z以外的其他Clip Space中的坐标<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> depth = i.pos.z * i.pos.w;</span><br><span class="line"><span class="keyword">return</span> half4(depth, depth, depth, <span class="number">1</span>); <span class="comment">// Ouput depth visualization</span></span><br></pre></td></tr></table></figure></p>
<p>还有一种方法是先在vert shader中将Clip Space坐标保存成一个顶点属性，然后交由硬件插值后传入frag shader。这里的重要区别是，GPU不会对没有标记SV_POSITION的顶点属性进行Perspective Divide和ViewPort Transform，进行的是含透视矫正的插值。由于是含透视矫正的，所以对于插值的属性，它按在Clip Space的深度进行插值，也就是说它的坐标值准确的对应于Clip Space下该frag的坐标。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> depth = i.pos_clip.z;</span><br><span class="line"><span class="keyword">return</span> half4(depth, depth, depth, <span class="number">1</span>); <span class="comment">// Ouput depth visualization</span></span><br></pre></td></tr></table></figure></p>
<p>有意思的是，如果我们将Clip Space坐标除以了w之后就可以得到NDC空间下的屏幕坐标，可以用来当uv采样texture看看是不是如我们期望的一样。<br>核心代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">    float4 pos:     SV_POSITION;</span><br><span class="line">    float2 uv:      TEXCOORD0;</span><br><span class="line">    float4 pos_clip:TEXCOORD1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata_all v)</span> </span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    ...</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.pos_clip = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">half4 frag(v2f i) : COLOR &#123;</span><br><span class="line">    <span class="keyword">return</span> tex2D(_MainTex, frac(i.pos_clip.xy / i.pos_clip.w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.4_rotate_first_billboard.gif" alt title>
<p>但是我们也会注意到一个问题，这是一个“真的”billboard，uv的中心也始终在屏幕（也就是摄像机）的中央，如果将摄像机进行平移，就会失去中心点。另外，随着摄像机的拉近和拉远也没有缩放效果。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.5_static_scale.gif" alt title="这与其说是billboard，倒不如说更像是个用几何体的轮廓制作的Mask"></p>
<h3 id="让Billboard跟随物体"><a href="#让Billboard跟随物体" class="headerlink" title="让Billboard跟随物体"></a>让Billboard跟随物体</h3><p>让我们先解决第一个问题，即让billboard跟着mesh走。方法是先计算出物体模型空间下的中心在Clip Space中的位置。由于已经有了当前frag的Clip Space坐标，我们就能算出当前frag距离物体中心的偏移量（注意此刻我们仍是在Clip Space中，后面还需转换到NDC中）。如果当前frag的Clip Space坐标和物体的中心一样，那么偏移量就为0，uv也对应的为0。在有更多偏移量的地方设置相应的uv，这样就实现了uv以<strong>物体中心</strong>而不是屏幕的中心为起点向周围发散。这会是一个很大的帮助，因为我们后面会要让每个billboard sprite紧紧附在对应的block上。</p>
<p>不过如果uv的起点是物体的中心，那贴图的左下角（UV为(0,0)）也会是会和中心对齐，这看上去就会很奇怪。我们要做的是指定GetNdcUv计算出的uv变为（0.5，0.5），即在计算出的uv加上（0.5，0.5）的偏移（等价于将texture向（-0.5，-0.5）的方向移动）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float3 center_block = float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">float3 offsetFromFloor_block = frac(<span class="number">1</span> + sign(i.pos_obj) * center_block);</span><br><span class="line"><span class="comment">// Origin we want the billboard to be in object space</span></span><br><span class="line">float3 offset_obj = sign(i.pos_obj) </span><br><span class="line">        * d * (offsetFromFloor_block + <span class="built_in">floor</span>(<span class="built_in">abs</span>(i.pos_obj * <span class="number">0.999</span>) / d));</span><br><span class="line">float4 uvOrigin_clip = UnityObjectToClipPos(float4(offset_obj.xyz, <span class="number">1.0</span>));</span><br><span class="line">float2 uv_ndc = pos_clip.xy / pos_clip.w;</span><br><span class="line">float2 uv_origin_ndc = uvOrigin_clip.xy / uvOrigin_clip.w;</span><br><span class="line"><span class="comment">// Caculate the uv offset from center in obj space</span></span><br><span class="line">uv_ndc.xy -= uv_origin_ndc;</span><br><span class="line">half4 screenTexture = tex2D(_MainTex, uv_ndc + center_block); <span class="comment">// The compensate offset here is actually incorrect since we only consider one direction.</span></span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.6_uv_correction.png" alt title>
<p>可以看到A1格已经到了左下角，没有完全对齐的原因是因为缩放比例还不正确。</p>
<p>我们也可以调节uvTiling让uv充满整个面（这个也可以自动算出，但是有时候美术的确可能需要手动调节sprite的大小）,如果想让sprite的anchor中心不再是物体的中心，也可以自己加offset细调，这会在<a href="#anchro_adjust">后面</a>提到。</p>
<h3 id="让Billboard带透视"><a href="#让Billboard带透视" class="headerlink" title="让Billboard带透视"></a>让Billboard带透视</h3><p>至于没有随着距离远近缩放的问题，可以通过<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv_ndc *= uvOrigin_clip.w;</span><br></pre></td></tr></table></figure></p>
<p>来解决，这是因为uv_ndc是在ndc下的offset，只有乘以了z才能变成Clip Space下的距离，实现uv“近小远大”，texture对应的近大远小。另外注意这里对于一个block，统一使用了中心点的w分量来做透视，这样可以保证整个面上所有的像素的深度都是一致的。虽然也可以通过与frag的w混合来实现一定程度的透视效果，但是这里就不展开了。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.7_perspective_correct.gif" alt title></p>
<h3 id="Tiled-Sprite-Layer"><a href="#Tiled-Sprite-Layer" class="headerlink" title="Tiled Sprite Layer"></a>Tiled Sprite Layer</h3><p>下一步就是实现 tilied sprite layer。<br>我们可以首先计算出每个block的边长<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> d = _BoundarySize/ _Tiling;</span><br></pre></td></tr></table></figure></p>
<p>同时将原始的object position也作为顶点属性传递到frag shader之后，可以计算出这属于第几个block，然后再加上半格的偏移就可以得到每个block中心的位置，要记得带上sign(i.originPos)，否则方向会是错的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> d = _Length / _PosTiling;</span><br><span class="line"><span class="comment">// Origin we want the billboard to be in object space</span></span><br><span class="line">float3 offset_obj = sign(i.pos_obj) * d * (<span class="built_in">floor</span>(<span class="built_in">abs</span>(i.pos_obj*<span class="number">0.999</span>) / d) + float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure></p>
<p>再将新的offset传入后，就能看到tilied的sprite了<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.8_tiled_billboard.gif" alt title></p>
<p><span id="anchro_adjust"></span><br>目前物体的旋转中心还是在物体的中央（每个block的(0.5,0.5,0.5)处）。我们要调整的是offset，因为它是我们认为的参考点（anchor），所以还要做一步偏移操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move the anchor to feet</span></span><br><span class="line">float3 center_block = float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) + float3(<span class="number">0</span>, <span class="number">-0.3</span>, <span class="number">0</span>);</span><br><span class="line">float3 offsetFromFloor_block = frac(<span class="number">1</span> + sign(i.pos_obj) * center_block);</span><br><span class="line">float3 offset_obj = sign(i.pos_obj) </span><br><span class="line">    * d * (offsetFromFloor_block + <span class="built_in">floor</span>(<span class="built_in">abs</span>(i.pos_obj * <span class="number">0.999</span>) / d));</span><br><span class="line">float3 intrudeDir_obj = normalize(offset_obj - cameraPos_obj);</span><br><span class="line">float2 uv_ndc = GetNdcUv(clipPos, _UvTiling, offset_obj.xyz - _Offset.w * intrudeDir_obj));</span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.9_align_to_anchor.gif" alt title="我将anchor gizmos放到了billboard在的中心，可以看到无论如何旋转相机，billboard的uv都能和它保持相对静止">
<p>为了验证我们的计算没有错误，我们可以比较虚拟billboard是否和真实的billboard有一样的显示。我在场景里放了一块传统的billboard，放置在和虚拟billboard同样的anchor点，然后旋转物体进行观察。结果可以看到两者完全重合在一起，证明了算法的准确性。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.10_compare_with_real_billboard.gif" alt title="你能发现藏在box中的真正的billboard吗"></p>
<p><img src="https://4.bp.blogspot.com/-fjxkTPOjjFY/W6YYGka4GeI/AAAAAAAAHZM/Z3cqOgvNANY76Ho3-_B81p1ZdmHa2j2DwCLcBGAs/s1600/Interior%2BMapping%2B-%2BFurniture.jpg" alt title=" 比较论文中的家具层的效果，可以看到会在某种程度上减小flat感"><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.11_final_result.gif" alt title="最终效果"></p>
<p><span id="culling_Wall"></span></p>
<h1 id="正确显示边角的遮挡"><a href="#正确显示边角的遮挡" class="headerlink" title="正确显示边角的遮挡"></a>正确显示边角的遮挡</h1><p>最后一步是，如果墙面正好在房间的外部一些，即我们的mesh之外一点。虽然表面上采样的点属于内腔，从正面看是不会看到遮挡的墙，但是从另一个角度看，则会看到本该被剔除的墙面。一般发生在墙面的转角处。这一点甚至在PS4 Spider-Man中都没有处理<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_wrong_corner_spider_man.png" alt title="注意画面左侧的墙面，本应该是窗户但是却显示了墙壁"><br>完整视频参考：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/YQVHtlVEirs?start=39" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>不过要想解决这个问题并不复杂。我们只用计算出最外层的坐标阈值，超出部分一律不绘制即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test if wall's z is out of box boundary</span></span><br><span class="line"><span class="keyword">float</span> zIsInsideBoundary = step(<span class="built_in">abs</span>(cameraPos_obj + ratio.z * cameraToPixelOffset_obj).z / (_BoundarySize * <span class="number">0.5</span>), <span class="number">0.999</span>);</span><br><span class="line"><span class="comment">// Test if wall's x is out of box boundary</span></span><br><span class="line"><span class="keyword">float</span> xIsInsideBoundary = step(<span class="built_in">abs</span>(cameraPos_obj + ratio.x * cameraToPixelOffset_obj).x / (_BoundarySize * <span class="number">0.5</span>), <span class="number">0.999</span>);</span><br><span class="line">...</span><br><span class="line">float4 wallXYCol = tex2D(_WallXYTexture, intersectionXY_obj) * zIsInsideBoundary;</span><br><span class="line">float4 wallZYCol = tex2D(_WallZYTexture, intersectionZY_obj) * xIsInsideBoundary;</span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_correct_corner.png" alt title="右边图中边缘多余的墙壁被剔除了">
<h1 id="后面的改进"><a href="#后面的改进" class="headerlink" title="后面的改进"></a>后面的改进</h1><p>1.通过事先bake好光照，使室内的表现更加真实。计算真实的光照也是有可能的，只不过可能需要更多的操作，需要权衡一下是否真的需要。<br>2.处理好不同方向的偏移补偿，目前的uv offset补偿其实是有问题的，没有考虑顶部和底部的情况。（不过如果大楼是封顶的倒也不太要紧）<br>3.本文使用的是分开的墙面texture方法，也有些实现使用的是Cubemap。<img src="https://forum.unity.com/attachments/interiormapping-cubemap-jpg.198474/" alt title="图片来源：[8]"></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://jsantell.com/model-view-projection" target="_blank" rel="noopener">[1] Model View Projection</a><br><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">[2] OpenGL Projection Matrix</a><br><a href="https://pdfs.semanticscholar.org/8622/48de620efe27705af3702ab2a2c0d4ec76ec.pdf" target="_blank" rel="noopener">[3] Interior Mapping - A new technique for rendering realistic buildings</a><br><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation" target="_blank" rel="noopener">[4] The Visibility Problem, the Depth Buffer Algorithm and Depth Interpolation</a><br><a href="http://pluspng.com/png-151110.html" target="_blank" rel="noopener">[5] Test Character Sprite</a><br><a href="http://wiki.amplify.pt/index.php?title=Unity_Products:Fake_Interiors/Manual" target="_blank" rel="noopener">[6] Unity Products:Fake Interiors/Manual</a><br><a href="http://joostdevblog.blogspot.com/2018/09/interior-mapping-real-rooms-without.html" target="_blank" rel="noopener">[7] Interior Mapping: rendering real rooms without geometry</a><br><a href="https://forum.unity.com/threads/interior-mapping.424676/" target="_blank" rel="noopener">[8] Unity Forum: Interior Mapping</a><br><a href="http://interiormapping.oogst3d.net/" target="_blank" rel="noopener">[9] Interior Mapping - A new technique for rendering realistic buildings</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/graphics/" rel="tag"># graphics</a>
          
            <a href="/tags/shader/" rel="tag"># shader</a>
          
            <a href="/tags/game/" rel="tag"># game</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/11/weekly-animation-share-vol-2/" rel="next" title="Weekly Animation Share Vol 2">
                <i class="fa fa-chevron-left"></i> Weekly Animation Share Vol 2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/07/mesh_quadric_downsampling/" rel="prev" title="使用Quadric Error Metrics进行mesh简化">
                使用Quadric Error Metrics进行mesh简化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
    </div>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  
  <aside id="sidebar" class="sidebar sidebar-hide">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <!--<li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>-->
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="tasiYokan">
          <p class="site-author-name" itemprop="name">tasiYokan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本思路的实现"><span class="nav-number">2.</span> <span class="nav-text">基本思路的实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可配置厚度墙面的实现"><span class="nav-number">3.</span> <span class="nav-text">可配置厚度墙面的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断像素是否在墙内"><span class="nav-number">3.1.</span> <span class="nav-text">判断像素是否在墙内</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用AND还是OR"><span class="nav-number">3.2.</span> <span class="nav-text">使用AND还是OR</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#制作Sprite-Layer"><span class="nav-number">4.</span> <span class="nav-text">制作Sprite Layer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#朴素的截面偏移层"><span class="nav-number">4.1.</span> <span class="nav-text">朴素的截面偏移层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#支持多方向适配"><span class="nav-number">4.1.1.</span> <span class="nav-text">支持多方向适配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类Billboard-Sprite-Layer"><span class="nav-number">4.2.</span> <span class="nav-text">类Billboard Sprite Layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统Billboard"><span class="nav-number">4.2.1.</span> <span class="nav-text">传统Billboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物体空间内的Billboard"><span class="nav-number">4.2.2.</span> <span class="nav-text">物体空间内的Billboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识准备"><span class="nav-number">4.2.3.</span> <span class="nav-text">基础知识准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让Billboard跟随物体"><span class="nav-number">4.2.4.</span> <span class="nav-text">让Billboard跟随物体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让Billboard带透视"><span class="nav-number">4.2.5.</span> <span class="nav-text">让Billboard带透视</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tiled-Sprite-Layer"><span class="nav-number">4.2.6.</span> <span class="nav-text">Tiled Sprite Layer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正确显示边角的遮挡"><span class="nav-number">5.</span> <span class="nav-text">正确显示边角的遮挡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后面的改进"><span class="nav-number">6.</span> <span class="nav-text">后面的改进</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#引用"><span class="nav-number">7.</span> <span class="nav-text">引用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  



        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tasiYokan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
      
  <div class="expand-toc">
    <i class="fa fa-list-ol"></i>
    
  </div>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
