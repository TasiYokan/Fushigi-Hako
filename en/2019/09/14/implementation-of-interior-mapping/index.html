<!doctype html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/en/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/en/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/en/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="graphics,shader,game,">








  <link rel="shortcut icon" type="image/x-icon" href="/en/favicon.ico?v=5.1.1">






<meta name="description" content="IntroductionInterior Mapping is a great way to display the building interior making use of optical illusion. While it does render the real room of a building from outside, all the work has been done">
<meta name="keywords" content="graphics,shader,game">
<meta property="og:type" content="article">
<meta property="og:title" content="Rendering building interior on a flat surface：Interior-Mapping">
<meta property="og:url" content="http://yoursite.com/2019/09/14/implementation-of-interior-mapping/index.html">
<meta property="og:site_name" content="不思議な箱">
<meta property="og:description" content="IntroductionInterior Mapping is a great way to display the building interior making use of optical illusion. While it does render the real room of a building from outside, all the work has been done">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.0_cover.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.1_basic_idea.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/0.2_conventions.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.0_without_wall_thickness.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.1_wrong_wall.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.2_xy_bool_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.3_all_bool_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.4_correct_wall.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.5_wrong_sphere.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.6_wrong_sphere_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.7_wrong_sphere_mask_top.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.8_correct_sphere_mask.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.9_potential_visual_bug.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.1_view_different_angle.gif">
<meta property="og:image" content="https://public-covers-1259535704.cos.ap-guangzhou.myqcloud.com/3.2_dirs_sprites.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/camera-space.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/perspective_correct_texture_mapping.jpg">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/ndc.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.3_unity_matrix.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.4_rotate_first_billboard.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.5_static_scale.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.6_uv_correction.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.7_perspective_correct.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.8_tiled_billboard.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.9_align_to_anchor.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.10_compare_with_real_billboard.gif">
<meta property="og:image" content="https://4.bp.blogspot.com/-fjxkTPOjjFY/W6YYGka4GeI/AAAAAAAAHZM/Z3cqOgvNANY76Ho3-_B81p1ZdmHa2j2DwCLcBGAs/s1600/Interior%2BMapping%2B-%2BFurniture.jpg">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.11_final_result.gif">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_wrong_corner_spider_man.png">
<meta property="og:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_correct_corner.png">
<meta property="og:image" content="https://forum.unity.com/attachments/interiormapping-cubemap-jpg.198474/">
<meta property="og:updated_time" content="2019-10-21T14:58:55.705Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rendering building interior on a flat surface：Interior-Mapping">
<meta name="twitter:description" content="IntroductionInterior Mapping is a great way to display the building interior making use of optical illusion. While it does render the real room of a building from outside, all the work has been done">
<meta name="twitter:image" content="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.0_cover.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/en/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/14/implementation-of-interior-mapping/">





  <title>Rendering building interior on a flat surface：Interior-Mapping | 不思議な箱</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/en/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不思議な箱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        <li class="menu-item menu-item-lang">
          <a href="/en/../" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-language"></i> <br>
            
            EN -> 中文
          </a>
        </li>
        
      
        
        
        <li class="menu-item menu-item-home">
          <a href="/en/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
        
      
        
        
        <li class="menu-item menu-item-about">
          <a href="/en/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
        
      
        
        
      
      <!-- 
      <li class="menu-item menu-item-home">
        <a href="/en/" rel="section">
          
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
          
          Home
        </a>
      </li> -->

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  

  

  <div class="site-author" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" src="/en/images/avatar.png" alt="tasiYokan">
    <p class="site-author-name" itemprop="name">tasiYokan</p>
      
        <p class="site-description motion-element" itemprop="description"></p>
    
  </div>

  <nav class="site-state">
    
      <div class="site-state-item site-state-posts">
        <a href="/en/archives/">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        <a href="/en/categories/index.html">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">categories</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        <a href="/en/tags/index.html">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <p></p>

  

  


</nav>


<script type="text/javascript">
    // Wait for the page to load first
    var _prevOnload = window.onload;
    var swithlang = function ()  {
        // var switchLang = document.getElementById("menu").getElementsByClassName("menu-item-switch_lang")[0].childNodes[0];
        var href = window.location.href;
        var menu = document.getElementById("menu");
        var switchLang = menu.getElementsByClassName("menu-item-lang")[0].getElementsByTagName("a")[0];

        var indexOfEn = href.toLowerCase().indexOf('/en/');
        if (indexOfEn !== -1) {
            // console.log("switch to cn from "+ switchLang.href );
            switchLang.href = href.replace('/en/', '/');
        }
        else {
            // console.log("switch to en from " + switchLang.href );
            switchLang.href = href.replace(/(^http[s]?:\/\/[a-z0-9.]*[:?0-9-]*[a-z0-9.]*\/)(.*)/i, '$1en/$2');
        }
        // console.log("href now is " + switchLang.href);
    }

    // Switch directly as the load may take a while
    // swithlang();

    window.onmousedown = function() {
        swithlang();
    }
</script>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <div class="post-inner">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/en/2019/09/14/implementation-of-interior-mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tasiYokan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/en/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不思議な箱">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Rendering building interior on a flat surface：Interior-Mapping</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-14T22:28:30+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/en/categories/Dev/" itemprop="url" rel="index">
                    <span itemprop="name">Dev</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
              <i class="fa fa-eye"></i>
            </span>
            
              <span class="post-meta-item-text">Views</span>
            
            <span class="page-pv">
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
         <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.0_cover.png" alt title="The final result">
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Interior Mapping is a great way to display the building interior making use of optical illusion. While it does render the real room of a building from outside, all the work has been done without any extra vertices. This definitely sounds great to any performance insensive scenes.<br>A Greate example to illustrate this could be a game scene located at a CBD where rendering each instance could be an aweful overhead for performance. Considering the obvious pattern we would see if we use the same texture for each room. Interior mapping turns out to be a compromising way to make it look good while maintaining the high fps.<br>This technique has several advantages in summary:</p>
<ol>
<li>The framerate or memory cost is independent from the amount of rooms. Actually, you can put as many room as you want into the scene, the performance would be exactly the same.</li>
<li>Since we can use the same wall many times for a building, we can render a “complex” scene with a little resources.</li>
<li>It requires no extra advance shader model featuers. Common SM3 model would be enough.<a id="more"></a>
</li>
</ol>
<h1 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h1><p>You can easily check Joost van Dongen’s paper <a href="https://pdfs.semanticscholar.org/8622/48de620efe27705af3702ab2a2c0d4ec76ec.pdf" target="_blank" rel="noopener">Interior Mapping - A new technique for rendering realistic buildings</a> to get the basic implementation.<br>There’s no big difference in the core implementation. So I won’t put too many words on explaining the details of it here.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/1.1_basic_idea.png" alt title="Some naming convention I use in this post"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reciprocal of each floor's height d</span></span><br><span class="line">float3 invert_d = _Tiling / _BoundarySize;</span><br><span class="line"></span><br><span class="line">float3 cameraPos_obj = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">float3 cameraToPixelOffset_obj = i.pos_obj - cameraPos_obj;</span><br><span class="line"></span><br><span class="line">float3 cameraStepDir_obj = step(float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cameraToPixelOffset_obj);</span><br><span class="line">float3 floorId = <span class="built_in">floor</span>(i.pos_obj * <span class="number">0.999</span> * invert_d)  + cameraStepDir_obj;</span><br><span class="line">float3 floorPos_obj = floorId / invert_d;</span><br><span class="line">float3 cameraToFloorIntersectionOffset_obj = floorPos_obj - cameraPos_obj;</span><br><span class="line"><span class="comment">// This is the ratio between the actual distance before reaching destination and the distance of pixel and camera in object space</span></span><br><span class="line">float3 ratio = cameraToFloorIntersectionOffset_obj / cameraToPixelOffset_obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here the intersection coordinate has been normalized through dividing by d</span></span><br><span class="line">float2 intersectionXY_obj = (cameraPos_obj + ratio.z * cameraToPixelOffset_obj).xy * invert_d;</span><br><span class="line">float2 intersectionXZ_obj = (cameraPos_obj + ratio.y * cameraToPixelOffset_obj).xz * invert_d;</span><br><span class="line">float2 intersectionZY_obj = (cameraPos_obj + ratio.x * cameraToPixelOffset_obj).zy * invert_d;</span><br><span class="line"></span><br><span class="line">float4 ceilingCol = tex2D(_CeilingTexture, intersectionXZ_obj);</span><br><span class="line">float4 floorCol = tex2D(_FloorTexture, intersectionXZ_obj);</span><br><span class="line">float4 horizonCol = lerp(floorCol, ceilingCol, step(<span class="number">0</span>, cameraToPixelOffset_obj.y));</span><br><span class="line"></span><br><span class="line">float4 wallXYCol = tex2D(_WallXYTexture, intersectionXY_obj);</span><br><span class="line">float4 wallZYCol = tex2D(_WallZYTexture, intersectionZY_obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check which face is closer to camera and pick it as the final texuture for specific pixel</span></span><br><span class="line"><span class="keyword">float</span> xLessThanZ = step(ratio.x, ratio.z);</span><br><span class="line">float4 verticalCol = lerp(wallXYCol, wallZYCol, xLessThanZ);</span><br><span class="line"><span class="keyword">float</span> ratioMin_x_z = lerp(ratio.z, ratio.x, xLessThanZ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x_zLessThanY = step(ratioMin_x_z, ratio.y);</span><br><span class="line">float4 innerCol = lerp(horizonCol, verticalCol, x_zLessThanY);</span><br></pre></td></tr></table></figure></p>
<p>The above code from paper has several problem though:</p>
<ol>
<li>There’s no parameter to set the thickness of a wall. Though we can manually put a wall texture outside. the floor of a room still lies on the very bottom of a cell.</li>
<li>We haven’t put a sprite layer to show the furniture or the people inside a room</li>
<li>When we view the interior through a corner, we can see the unexpected wall on the other side.</li>
</ol>
<p>Some definitation we will use throughout the whole post:<br>Block: Each room is called Block<br>Cavity: The space inside a block where hasn’t been occupied by walls<br>d: represent the lenght of a block in one direction.<br>_BoundarySize: The whole cube shaped boundary Mesh’s edge length<br>_Tiling: Times a cube is being cut in one direction<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/0.2_conventions.png" alt title="Illustration of some varibles we are going to use in the article"></p>
<h1 id="Configurable-Wall-Thickness"><a href="#Configurable-Wall-Thickness" class="headerlink" title="Configurable Wall Thickness"></a>Configurable Wall Thickness</h1><p>If not showing the wall thickness, it will place the floor at wrong position.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.0_without_wall_thickness.png" alt title="Image from [6]"></p>
<p>To fix that, we can easily intrude the origin wall at corresponding direction so that we can feel the thickness.<br>We first need to get some camera variables so that we can decide how much we intrude later.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 cameraPos_obj = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span class="number">1.0</span>)).xyz;</span><br><span class="line">float3 cameraToPixelOffset_obj = i.pos_obj - cameraPos_obj;</span><br><span class="line">float3 cameraStepDir_obj = step(float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cameraToPixelOffset_obj); <span class="comment">// return 1 if it's positive, otherwise 0</span></span><br></pre></td></tr></table></figure></p>
<p>The origin wall position is<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">floor</span>(i.positionCopy * <span class="number">0.999</span> / _d)  + stepDir</span><br></pre></td></tr></table></figure></p>
<p>To simulate the intrusion, we need to substract a wall thickness<code>(stepDir - float3(0.5, 0.5, 0.5)) * _WallThickness</code>, after that, we have to get the ratio of similar triangles.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 ratio = ((<span class="built_in">floor</span>(i.positionCopy * <span class="number">0.999</span> / _d)  + stepDir - (stepDir - float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)) * _WallThickness) * _d  - cameraPos_obj) / direction;</span><br></pre></td></tr></table></figure></p>
<p>However, if you followed the above instruction, the result would be the same as following<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.1_wrong_wall.png" alt title="We feel weird because we saw the place where should be hidden from wall face"></div><br>When we look the building from top, our eye sight will pass through the horizontal wall and “see” the inner face which should not be seen in the real world.</p>
<h2 id="Test-if-pixel-is-inside-the-wall"><a href="#Test-if-pixel-is-inside-the-wall" class="headerlink" title="Test if pixel is inside the wall"></a>Test if pixel is inside the wall</h2><p>Now the solution to fix the problem is to find which position on the wall is the specific pixel realted to.<br>We can use the “floor” operation to get the center of each block.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 floorId = <span class="built_in">floor</span>(i.vertexPos  * <span class="number">0.999</span> / _d);</span><br><span class="line">float3 centerPos_obj = (floorId + <span class="number">0.5</span>) * _d;</span><br><span class="line">float3 offsetFromCenter_obj = <span class="built_in">abs</span>(i.vertexPos - centerPos_obj) / _d;</span><br></pre></td></tr></table></figure></p>
<p>here centerPos_obj is in the object space, while offsetFromCenter_obj is the normalized offset ranged in [0, 1], representing the offset ratio in each block.</p>
<p>One way to check if one point is inside the wall is:<br>See if any of the coordinate channel has exceed the radius of cavity. Take xy plane as an example<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> max_xy = max(offsetFromCenter_obj.x, offsetFromCenter_obj.y);</span><br><span class="line"><span class="keyword">float</span> mask = step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_xy );</span><br></pre></td></tr></table></figure></p>
<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.2_xy_bool_mask.png" alt title></div><br>The same method can be applied to other 2 planes. To sum up,<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> max_xy = max(offsetFromCenter_obj.x, offsetFromCenter_obj.y);</span><br><span class="line"><span class="keyword">float</span> mask = step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_xy );</span><br><span class="line"><span class="keyword">float</span> max_xz = max(offsetFromCenter_obj.x, offsetFromCenter_obj.z);</span><br><span class="line">mask *= step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_xz );</span><br><span class="line"><span class="keyword">float</span> max_yz = max(offsetFromCenter_obj.y, offsetFromCenter_obj.z);</span><br><span class="line">mask *= step((<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>, max_yz );</span><br></pre></td></tr></table></figure><br><br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.3_all_bool_mask.png" alt title></div><br>Here the mask behaves like an “AND” bool operation. Only the pixel lies in the projection of cavity on all 3 plane can be considered as in the cavity. Those pixel’s final bool value would be 0.<br>If it’s too abstract for you to understand. You can imagine we are cull the volume that not a part of wall on a cube. The rest white part is our walls.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 outerCol = tex2D(_outerWallTexture, i.uv);</span><br><span class="line">float4 finalCol = lerp(innerCol, outerCol, mask);</span><br></pre></td></tr></table></figure><br><br>The result of this step would be<br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.4_correct_wall.png" alt title></div>

<h2 id="Should-we-use-“AND”-or-“OR”"><a href="#Should-we-use-“AND”-or-“OR”" class="headerlink" title="Should we use “AND” or “OR”"></a>Should we use “AND” or “OR”</h2><p>When we performing “AND” bool operations, we actually cull some of the inner walls. Luckily, for cube, we only need the outmost mask value so it’s not the end of the world. However, it becomes an annoying problem when we comes to irregular shapes like sphere as we can see the inner structure. The wall that be culled by mistake would looks weird.</p>
<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.5_wrong_sphere.png" alt title></div><br>To make the problem easier, we can only output the bool value.<br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.6_wrong_sphere_mask.png" alt title></div><br>We can see the inner wall was cut incorrectly from the sphere surface.<br>We can have a clear view from the top view.<br><div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.7_wrong_sphere_mask_top.png" alt title="Here I marked the mask on xz plane with red"></div>

<p>To fix this problem, we need to switch “AND” to “OR” bool operation. If any of the position channel exceeds the cavity, we would think it as inside the wall. And it makes sense inour common sense.<br>Notice, if we use “OR” operation instead, we actually only need to check 2 directions as the third plane infomation would be redundant.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> max_xy = max(offsetFromCenter_obj.x, offsetFromCenter_obj.y);</span><br><span class="line"><span class="keyword">float</span> mask = step(max_xy, (<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">float</span> max_xz = max(offsetFromCenter_obj.x, offsetFromCenter_obj.z);</span><br><span class="line">mask *= step(max_xz, (<span class="number">1</span> - _WallThickness) * <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// float max_yz = max(offsetFromCenter_obj.y, offsetFromCenter_obj.z);</span></span><br><span class="line"><span class="comment">// mask *= step(max_yz, (1 - _WallThickness) * 0.5);</span></span><br><span class="line">mask = <span class="number">1</span> - mask;</span><br></pre></td></tr></table></figure></p>
<div style="width: 60%; margin: auto"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.8_correct_sphere_mask.png" alt title="This time it looks good"></div>

<p>However, it brings another problem.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/2.9_potential_visual_bug.png" alt title><br>When the tiling of block reaches a certain number(like 2, 4, 6…), the wall is exactly on the edge of the cube. As a result, the whole surce is covered by walls. I once tried to check it in the shader automatically, but I gave up. I decided to let the user to make the right tiling for the building cause they may have their own use.<br>Interestingly, the “AND” bool operation will not have this problem.<br>And if you really want to fix this in the shader, you can check if the pixel is outside the bounding box. you can check <a href="#culling_Wall">Show the correct occulusion of the corner</a></p>
<h1 id="Making-Sprite-Layer"><a href="#Making-Sprite-Layer" class="headerlink" title="Making Sprite Layer"></a>Making Sprite Layer</h1><h2 id="Navie-sprite-layer-offset"><a href="#Navie-sprite-layer-offset" class="headerlink" title="Navie sprite layer offset"></a>Navie sprite layer offset</h2><p>The paper I refered also mentions a way to put furniture and human in side the empty room. It’s not difficulty, we just put a alpha wall in front of the origin wall.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intrude XY wall along Z axis by 0.4 block length</span></span><br><span class="line">float3 spriteOffset_block = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.4</span>);</span><br><span class="line">float3 cameraStepDir_obj = step(float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cameraToPixelOffset_obj);</span><br><span class="line">float3 floorId = <span class="built_in">floor</span>(i.pos_obj * <span class="number">0.999</span> * invert_d) + cameraStepDir_obj;</span><br><span class="line">float3 spriteLayerRatio = ((floorId - spriteOffset_block) / invert_d  - cameraPos_obj) / cameraToPixelOffset_obj;</span><br><span class="line">float2 S_intersectionXY = (cameraPos_obj + spriteLayerRatio.z * cameraToPixelOffset_obj).xy  * invert_d;</span><br><span class="line">float2 S_intersectionZY = (cameraPos_obj + spriteLayerRatio.x * cameraToPixelOffset_obj).zy  * invert_d;</span><br><span class="line">float4 S_XYCol = tex2D(_SpriteTex, S_intersectionXY);</span><br><span class="line">float4 S_ZYCol = tex2D(_SpriteTex, S_intersectionZY);</span><br><span class="line"><span class="keyword">float</span> S_xLessThanZ = step(spriteLayerRatio.x, spriteLayerRatio.z);</span><br><span class="line">float4 S_verticalCol = lerp(S_XYCol, S_ZYCol, S_xLessThanZ);</span><br><span class="line"><span class="keyword">float</span> S_ratioMin_x_z = lerp(spriteLayerRatio.z, spriteLayerRatio.x, S_x_less_z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> ratioMin_xyz = lerp(ratio.y, ratioMin_x_z, xzLessThanY);</span><br><span class="line"><span class="comment">// To see if it's closer than the origin wall</span></span><br><span class="line"><span class="keyword">float</span> S_isLess = step(S_ratioMin_x_z, ratioMin_xyz);</span><br><span class="line"><span class="comment">// If sprite layer is closer and the alpha is greater than 0, replace old pixel of wall by sprite layer</span></span><br><span class="line">innerCol = lerp(innerCol, S_verticalCol, S_isLess * S_verticalCol.a);</span><br></pre></td></tr></table></figure>
<p>Its shortage is obvious, that we can only get the correct view from the front view. When we view the furniture/sprite layer at a glazing angle, we can easily notice the fact that it is just a quad.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.1_view_different_angle.gif" alt title="View from different angle"></p>
<h3 id="Support-multi-direction"><a href="#Support-multi-direction" class="headerlink" title="Support multi-direction"></a>Support multi-direction</h3><p>First solution is we can manually assign the sprite layer based on different orientation.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// If the tile's unilateral count(from the center to this tile) reach half of total tiling, means it's the side tile</span></span><br><span class="line"><span class="keyword">float</span> isSideOrFront = <span class="built_in">abs</span>(<span class="built_in">ceil</span>(i.pos_obj * <span class="number">0.999</span> * invert_d).x) / (_Tiling.x/<span class="number">2</span>) &gt; <span class="number">0.999</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"><span class="comment">// Pick the color from side texture</span></span><br><span class="line">float4 S_verticalCol = lerp(S_XYCol, S_ZYCol, isSideOrFront);</span><br><span class="line"><span class="comment">// Here we use the ratio of the face we decided to use in above step to overwrite the actual minimal one "S_x_less_z"</span></span><br><span class="line"><span class="keyword">float</span> S_ratioMin_x_z = lerp(spriteRatio.z, spriteRatio.x, isSideOrFront);</span><br><span class="line">float2 halfTileCount = lerp(S_intersectionXY_ori, S_intersectionZY_ori, isSideOrFront) / _Tiling.x * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Because our sprite will keep repeating, even in the place we should not see it. Luckily, we can use the time it repeats to see if it's out of the valid display region.</span></span><br><span class="line"><span class="keyword">bool</span> validSpriteRegion = <span class="number">1</span></span><br><span class="line">    * step(<span class="built_in">abs</span>(halfTileCount.y), <span class="number">1</span>) </span><br><span class="line">    * step(<span class="built_in">abs</span>(halfTileCount.x), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> ratioMin_xyz = lerp(ratio.y, S_ratioMin_x_z, xzLessThanY);</span><br><span class="line"><span class="keyword">float</span> S_isLess = step(S_ratioMin_x_z, ratioMin_xyz) * validSpriteRegion;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>

<p><img src="https://public-covers-1259535704.cos.ap-guangzhou.myqcloud.com/3.2_dirs_sprites.png" alt title="The result is not good enough"></p>
<h2 id="Billboard-Sprite-Like-Layer"><a href="#Billboard-Sprite-Like-Layer" class="headerlink" title="Billboard Sprite Like Layer"></a>Billboard Sprite Like Layer</h2><p>However, the above method not only get rigid when adapt to different angles (not to say if we don’t have axis aligned surface), but also creates a lot of hardcode in the shader. A more elegant way to do that is to make it adapat to any arbitrary angle. What comes to my mind first was something like billboard that can follow our camera.</p>
<h3 id="Traditional-Billboard"><a href="#Traditional-Billboard" class="headerlink" title="Traditional Billboard"></a>Traditional Billboard</h3><p>The traditional billboard is to translate vertex in vertex shader: assign the coordinate in Object Space with the one in View Space.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4 billboardPos = mul(UNITY_MATRIX_P,</span><br><span class="line">    mul(UNITY_MATRIX_MV, float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)) <span class="comment">// We still need to record the center of object, otherwise the billboard will always in the center of screen</span></span><br><span class="line">    + float4(v.vertex.x, v.vertex.y, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure></p>
<p>Obviously, this can not be applied to our case as ohter further opertaions like tiling or something will depend on the origin vertex position. And because we are not going to tesellate our vertices, we won’t be able to transfer those virtual vertices.(We won’t use gemotry shader here)</p>
<h3 id="Object-Space-Billboard"><a href="#Object-Space-Billboard" class="headerlink" title="Object Space Billboard"></a>Object Space Billboard</h3><p>Our idea is to make the vertex position still while using each pixel’s projection on “virtual billboard”</p>
<h3 id="Knowledge-prepartion"><a href="#Knowledge-prepartion" class="headerlink" title="Knowledge prepartion"></a>Knowledge prepartion</h3><p>In the general rendering pipeline. The input vertex data is in the Object space/ Model Space. After a sequence of Model Matrix, View Matrix, Projection Matrix and Viewport Transform, they will become the coordiante on the screen. In diferent articles, the definitation of Projection Matrix will have difference which may confuse reader. We here define the Projection Matrix as the matrix to transfer object from View Space(Eye Space) to NDC Space.<br>A Complete Projection Matrix includs two parts:<br>first part is the “linear” scaling that makes original View Frustum to the similar “View Frustum” whose near clip face is $[-Z_{near}, Z_{near}]$ while the depth value is only “1”. In Clip space, any attribute can be interpolated by vertex attribute based on any of x,y,z axis.<br>$$<br>\left[<br>\begin{array}{cccc}<br> x_{clip}\\<br> y_{clip}\\<br> z_{clip}\\<br> 1<br>\end{array}<br>\right ]<br>=<br>\left[<br>\begin{array}{cccc}<br> \frac{ {2n} }{ {r-l} } &amp; 0 &amp; \frac{ {r+l} }{ {r-l} }  &amp; 0 \\<br> 0 &amp; \frac{ {2n} }{ {t-b} } &amp; \frac{ {t+b} }{ {t-b} }  &amp; 0 \\<br> 0 &amp; 0                      &amp; \frac{ {-(f+n)} }{ {f-n} } &amp; \frac{ {-2fn} }{ {f-n} } \\<br> 0 &amp; 0 &amp; -1 &amp; 0 \\<br>\end{array}<br>\right ]<br>\left[<br>\begin{array}{cccc}<br> x_{view}\\<br> y_{view}\\<br> z_{view}\\<br> 1<br>\end{array}<br>\right ]<br>$$<br>This step happens at vertex shader.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/camera-space.png" alt title="What we shows here is in Camera Space, But the shape in Clip Space would be similar. Image from [1]"><br>In the second part, we are going to transfer vertex from Clip Space to NDC(Normalized Device Coordinates) Space through Perspective Divide. NDC Space is compressing in a way that near objects get more compressing than those far away from camera.<br>NDC has another interesting feature: If we want to calcuate any point’s attribute in the space, we won’t get the correct result from Barycentric Interpolation Interpolation because of the uneven depth distribution.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/perspective_correct_texture_mapping.jpg" alt title="The middle one is the not pefroming perspective correction. Image from Wikipedia"><br>The solution is to use Perspective Correction. If we konw vertex P1, P2’s properties, then value of any P on the segment would be<br>$$p=z[\frac{p_1}{z_1}(1-t) + \frac{p_2}{z_2}t]$$<br>To understand this in an easier way, you have to first scaling attributes based on depth before applying linear interpolation. The detailed explaination can be checkd at <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation" target="_blank" rel="noopener">scratchapixel</a></p>
<p>Perspective Divide’s matrix form<br>$$<br>\left[<br>\begin{array}{cccc}<br> x_{ndc}\\<br> y_{ndc}\\<br> z_{ndc}<br>\end{array}<br>\right ]<br>=<br>\left[<br>\begin{array}{cccc}<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}<br>\end{array}<br>\right ]^{\mathsf{T}}<br>\left[<br>\begin{array}{cccc}<br> x_{clip}\\<br> y_{clip}\\<br> z_{clip}<br>\end{array}<br>\right ]<br>$$<br>This would be automatically performed before frag shader.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/ndc.png" alt title="Notice here z axis is opposite. Image from [1]"><br>if apply attributes in Clip Space, the result will have distortion because of the unevenly scaled vertex position.</p>
<p>Now, after haveing the two parts, a complete Projection Matrix can be expressed as<br>$$<br>[M_{Proj}] =<br>\left[<br>\begin{array}{cccc}<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}\\<br>    \frac{1}{-z_{view}}\\<br>    N/A<br>\end{array}<br>\right ]^{\mathsf{T}}<br>\left[<br>\begin{array}{cccc}<br> \frac{ {2n} }{ {r-l} } &amp; 0 &amp; \frac{ {r+l} }{ {r-l} }  &amp; 0 \\<br> 0 &amp; \frac{ {2n} }{ {t-b} } &amp; \frac{ {t+b} }{ {t-b} }  &amp; 0 \\<br> 0 &amp; 0                      &amp; \frac{ {-(f+n)} }{ {f-n} } &amp; \frac{ {-2fn} }{ {f-n} } \\<br> 0 &amp; 0 &amp; -1 &amp; 0<br>\end{array}<br>\right ]<br>$$</p>
<p>If we use the input position xy value in frag shader directly (useing semantics binding SV_POSITION) to map billboard’s uv, it can be used to map to screen space. But it actually is the same as gl_FragCoord and is not easily work for further operations. I want to add on SV_POSITION a little bit. Though SV_POSITION is in Clip Space when in vert shader, it gets Perspective Divide before entering frag shader. (some hardware will hand it over frag shader, but still get done before the programable part so we can still think it as before frag shader). That’s to say, SV_POSITION get perspected and now in NDC.<br>Though DirectX, OpenGL and Vulkan makes different implementations of projection matrix in Unity. But their w channel is always $Z_{view}$(Although in Projection Matrix $w = -Z_{view}$in the preivous View Matrix, it has already been negated), So we can divide this w channel to make the perspective transfromation.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.3_unity_matrix.png" alt title><br>All values in Screen Space can only be interpolated via NDC’s coordinate. Positions in Clip Space and View Space is “linear” and be affine to World Space.</p>
<p>Frag shader’s input SV_POSITION’s z is in NDC, However, we ned to calcuate position reltive to reference point and reference point is not getting perspective divide. Thus, to make things eaiser, we make everything in Clip Space and convert to NDC in the last step.<br>To get pixel in Clip Space, we have to approaches,<br>First is to invertly times a w to the coordinate in NDC to get a position in Clip Space. However, because SV_POSITION is not in NDC, so we cannot get other position channels in Clip Space expcet z.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> depth = i.pos.z * i.pos.w;</span><br><span class="line"><span class="keyword">return</span> half4(depth, depth, depth, <span class="number">1</span>); <span class="comment">// Ouput depth visualization</span></span><br></pre></td></tr></table></figure></p>
<p>Another way is to first save vert attributes in Clip Space while in vert shader. Then pass the interpolated value to frag shader. The important difference here is, GPU will not perform Perspective Divide and ViewPort Transformation on attributes not marked as SV_POSITION. That’s to say, this values get perspective correction, and their value is based on their depth in Clip Space.(also the frag coordinate in Clip Space)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> depth = i.pos_clip.z;</span><br><span class="line"><span class="keyword">return</span> half4(depth, depth, depth, <span class="number">1</span>); <span class="comment">// Ouput depth visualization</span></span><br></pre></td></tr></table></figure></p>
<p>Interestingly, if we diivide the coordiante in Clip Space by w, we can get the screen space coordiante in NDC. We of course can sampling a texture use UV to see if things go as we expected<br>Core code is listed below<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">    float4 pos:     SV_POSITION;</span><br><span class="line">    float2 uv:      TEXCOORD0;</span><br><span class="line">    float4 pos_clip:TEXCOORD1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata_all v)</span> </span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    ...</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.pos_clip = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">half4 frag(v2f i) : COLOR &#123;</span><br><span class="line">    <span class="keyword">return</span> tex2D(_MainTex, frac(i.pos_clip.xy / i.pos_clip.w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.4_rotate_first_billboard.gif" alt title>
<p>However, We also notice that, it’s a “real” billboard, the center of uv is also in the center of screen(camera). We will lost center point if we pan the camera. Even worse, our scaling also takes no effect.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.5_static_scale.gif" alt title="It's more like we are applying a gemotrey mask on the background texture"></p>
<h3 id="Let-Billboard-Follow-The-Object"><a href="#Let-Billboard-Follow-The-Object" class="headerlink" title="Let Billboard Follow The Object"></a>Let Billboard Follow The Object</h3><p>The first thing we want to solve is to make billboard follows mesh. The way to do it is to first get the Clip Space position of center of object in Object Space. Because we already have the coordinate of current frag in Clip Space, we can get the offset of this frag to the center of object (Notice we are still in Clip Space and need a transformation to NDC later) If current farg is at the same position of object center, the offset becomes 0. The further it’s away from center, the larger offset it will have. Then <strong>Object center</strong> based UV can be achieved. This is a great help as we later need to attach each billboard sprite to the block later.</p>
<p>If the start of uv is the center of object, then the lower-left corner (where uv is (0,0)) will be placed at the cneter as well which looks weird. What we hope to do is to make the uv from GetNdcUv to add (0,5,0.5), which indeed make texture move along (-0.5, -0.5);<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float3 center_block = float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">float3 offsetFromFloor_block = frac(<span class="number">1</span> + sign(i.pos_obj) * center_block);</span><br><span class="line"><span class="comment">// Origin we want the billboard to be in object space</span></span><br><span class="line">float3 offset_obj = sign(i.pos_obj) </span><br><span class="line">        * d * (offsetFromFloor_block + <span class="built_in">floor</span>(<span class="built_in">abs</span>(i.pos_obj * <span class="number">0.999</span>) / d));</span><br><span class="line">float4 uvOrigin_clip = UnityObjectToClipPos(float4(offset_obj.xyz, <span class="number">1.0</span>));</span><br><span class="line">float2 uv_ndc = pos_clip.xy / pos_clip.w;</span><br><span class="line">float2 uv_origin_ndc = uvOrigin_clip.xy / uvOrigin_clip.w;</span><br><span class="line"><span class="comment">// Caculate the uv offset from center in obj space</span></span><br><span class="line">uv_ndc.xy -= uv_origin_ndc;</span><br><span class="line">half4 screenTexture = tex2D(_MainTex, uv_ndc + center_block); <span class="comment">// The compensate offset here is actually incorrect since we only consider one direction.</span></span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.6_uv_correction.png" alt title>
<p>Now you can see A1 has been moved to lower-left. The reason why it’s not completely aligned is because our scaling is not correct yet.</p>
<p>We can also adjust uvTiling to make the uv fill the whole face.(This can be done automatically, but in case artists want to adjust it manually) if sprite’s anchor is no more the cneter of object. we can then use our own offset. This will be mentioned <a href="#anchro_adjust">later</a></p>
<h3 id="Billboard-With-Perspect-View"><a href="#Billboard-With-Perspect-View" class="headerlink" title="Billboard With Perspect View"></a>Billboard With Perspect View</h3><p>Regarding the problem that texture is not scaled based on the distance, we can<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv_ndc *= uvOrigin_clip.w;</span><br></pre></td></tr></table></figure></p>
<p>to solve. This is because uv_ndc is the offset in NDC. It turns to distance in Clip Space only when times z. Another thing I want to mention is, for each pixel on a block, we always use the center point’s w to make perspective in which way we can make the depth of all points on the surface the same. We can blende it with frag’s real w, but we wont talk too much here.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.7_perspective_correct.gif" alt title></p>
<h3 id="Tiled-Sprite-Layer"><a href="#Tiled-Sprite-Layer" class="headerlink" title="Tiled Sprite Layer"></a>Tiled Sprite Layer</h3><p>Next step will be making tilied sprite layer<br>We can first get the length of each block.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> d = _BoundarySize/ _Tiling;</span><br></pre></td></tr></table></figure></p>
<p>Meanwhile, we can calculated out which block it belongs to after passing original object position to frag shader as vert attribute. Adding half block offset will make the center of each bolck. Don’t forget to put sign(i.originPos), otherwise the directions will mess up.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> d = _Length / _PosTiling;</span><br><span class="line"><span class="comment">// Origin we want the billboard to be in object space</span></span><br><span class="line">float3 offset_obj = sign(i.pos_obj) * d * (<span class="built_in">floor</span>(<span class="built_in">abs</span>(i.pos_obj*<span class="number">0.999</span>) / d) + float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure></p>
<p>After passing the new offset, we can then see the tiled sprites<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.8_tiled_billboard.gif" alt title></p>
<p><span id="anchro_adjust"></span><br>For now, the cneter of rotation is still in the center of object.(the (0,5, 0.5, 0.5) in each block). We should to do one more step to adjust anchor’s offset.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move the anchor to feet</span></span><br><span class="line">float3 center_block = float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) + float3(<span class="number">0</span>, <span class="number">-0.3</span>, <span class="number">0</span>);</span><br><span class="line">float3 offsetFromFloor_block = frac(<span class="number">1</span> + sign(i.pos_obj) * center_block);</span><br><span class="line">float3 offset_obj = sign(i.pos_obj) </span><br><span class="line">    * d * (offsetFromFloor_block + <span class="built_in">floor</span>(<span class="built_in">abs</span>(i.pos_obj * <span class="number">0.999</span>) / d));</span><br><span class="line">float3 intrudeDir_obj = normalize(offset_obj - cameraPos_obj);</span><br><span class="line">float2 uv_ndc = GetNdcUv(clipPos, _UvTiling, offset_obj.xyz - _Offset.w * intrudeDir_obj));</span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.9_align_to_anchor.gif" alt title="I put anchor gizmos to the center of billboard. You can see billboard's uv is always align to the anchor no matter how I rotate camera">
<p>To confirm I didn’t make any mistake here, I compare the virtual billboard to real billboard. I put a traditional billboard at the same anchor as virtual billboard and rotate the object. We can see they aligned exactly in any angle, It looks pretty good so far.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.10_compare_with_real_billboard.gif" alt title="Can you tell the real billboard in the box?"></p>
<p><img src="https://4.bp.blogspot.com/-fjxkTPOjjFY/W6YYGka4GeI/AAAAAAAAHZM/Z3cqOgvNANY76Ho3-_B81p1ZdmHa2j2DwCLcBGAs/s1600/Interior%2BMapping%2B-%2BFurniture.jpg" alt title=" Compare to the furniture in the paper, you can see there&#39;s less flat feeling here"><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/3.11_final_result.gif" alt title="Final result"></p>
<p><span id="culling_Wall"></span></p>
<h1 id="Show-the-correct-occulusion-of-the-corner"><a href="#Show-the-correct-occulusion-of-the-corner" class="headerlink" title="Show the correct occulusion of the corner"></a>Show the correct occulusion of the corner</h1><p>Finally, we come to the last step. If the wall is exactly a little bit out of our building (mesh). We wont’ see the front wall, but the unexpected side wall is quite annoying. This happens a lot at the corner of the building. You can have a even more obvious example in  Spider-Man on PS4.<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_wrong_corner_spider_man.png" alt title="Notice the left side wall, it should be window, but it's not"><br>Full video reference：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/YQVHtlVEirs?start=39" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Luckily, it’s not too difficult to solve it. We only need to get the outermost position threshold. Any parts that exceeds the value will not get painted.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test if wall's z is out of box boundary</span></span><br><span class="line"><span class="keyword">float</span> zIsInsideBoundary = step(<span class="built_in">abs</span>(cameraPos_obj + ratio.z * cameraToPixelOffset_obj).z / (_BoundarySize * <span class="number">0.5</span>), <span class="number">0.999</span>);</span><br><span class="line"><span class="comment">// Test if wall's x is out of box boundary</span></span><br><span class="line"><span class="keyword">float</span> xIsInsideBoundary = step(<span class="built_in">abs</span>(cameraPos_obj + ratio.x * cameraToPixelOffset_obj).x / (_BoundarySize * <span class="number">0.5</span>), <span class="number">0.999</span>);</span><br><span class="line">...</span><br><span class="line">float4 wallXYCol = tex2D(_WallXYTexture, intersectionXY_obj) * zIsInsideBoundary;</span><br><span class="line">float4 wallZYCol = tex2D(_WallZYTexture, intersectionZY_obj) * xIsInsideBoundary;</span><br></pre></td></tr></table></figure></p>
 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/imp-interior-mapping/4.1_correct_corner.png" alt title="The one on the right shows how redundant wall was be culled">
<h1 id="Future-Improvement"><a href="#Future-Improvement" class="headerlink" title="Future Improvement"></a>Future Improvement</h1><ol>
<li>Use prebaked lighting to make the interior more realistic. I am not sure if we can use the real-time light in, but it should take a good consideration before trying it in the game.</li>
<li>Make a better compensate on different direction. Current uv offset compensate has some problem. We didn’t consider the case of top and button (But it’s not a big deal if the building has a cap lol)</li>
<li>I use wall texture here, some other implementation uses Cubemap, you can check it here<img src="https://forum.unity.com/attachments/interiormapping-cubemap-jpg.198474/" alt title="Image from [8]"></li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://jsantell.com/model-view-projection" target="_blank" rel="noopener">[1] Model View Projection</a><br><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">[2] OpenGL Projection Matrix</a><br><a href="https://pdfs.semanticscholar.org/8622/48de620efe27705af3702ab2a2c0d4ec76ec.pdf" target="_blank" rel="noopener">[3] Interior Mapping - A new technique for rendering realistic buildings</a><br><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation" target="_blank" rel="noopener">[4] The Visibility Problem, the Depth Buffer Algorithm and Depth Interpolation</a><br><a href="http://pluspng.com/png-151110.html" target="_blank" rel="noopener">[5] Test Character Sprite</a><br><a href="http://wiki.amplify.pt/index.php?title=Unity_Products:Fake_Interiors/Manual" target="_blank" rel="noopener">[6] Unity Products:Fake Interiors/Manual</a><br><a href="http://joostdevblog.blogspot.com/2018/09/interior-mapping-real-rooms-without.html" target="_blank" rel="noopener">[7] Interior Mapping: rendering real rooms without geometry</a><br><a href="https://forum.unity.com/threads/interior-mapping.424676/" target="_blank" rel="noopener">[8] Unity Forum: Interior Mapping</a><br><a href="http://interiormapping.oogst3d.net/" target="_blank" rel="noopener">[9] Interior Mapping - A new technique for rendering realistic buildings</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/en/tags/graphics/" rel="tag"># graphics</a>
          
            <a href="/en/tags/shader/" rel="tag"># shader</a>
          
            <a href="/en/tags/game/" rel="tag"># game</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/en/2019/09/11/weekly-animation-share-vol-2/" rel="next" title="Weekly Animation Share Vol 2">
                <i class="fa fa-chevron-left"></i> Weekly Animation Share Vol 2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
    </div>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  
  <aside id="sidebar" class="sidebar sidebar-hide">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <!--<li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>-->
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/en/images/avatar.png" alt="tasiYokan">
          <p class="site-author-name" itemprop="name">tasiYokan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/en/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/en/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/en/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Basic-Idea"><span class="nav-number">2.</span> <span class="nav-text">Basic Idea</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Configurable-Wall-Thickness"><span class="nav-number">3.</span> <span class="nav-text">Configurable Wall Thickness</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Test-if-pixel-is-inside-the-wall"><span class="nav-number">3.1.</span> <span class="nav-text">Test if pixel is inside the wall</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Should-we-use-“AND”-or-“OR”"><span class="nav-number">3.2.</span> <span class="nav-text">Should we use “AND” or “OR”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Making-Sprite-Layer"><span class="nav-number">4.</span> <span class="nav-text">Making Sprite Layer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Navie-sprite-layer-offset"><span class="nav-number">4.1.</span> <span class="nav-text">Navie sprite layer offset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Support-multi-direction"><span class="nav-number">4.1.1.</span> <span class="nav-text">Support multi-direction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Billboard-Sprite-Like-Layer"><span class="nav-number">4.2.</span> <span class="nav-text">Billboard Sprite Like Layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Traditional-Billboard"><span class="nav-number">4.2.1.</span> <span class="nav-text">Traditional Billboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Space-Billboard"><span class="nav-number">4.2.2.</span> <span class="nav-text">Object Space Billboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Knowledge-prepartion"><span class="nav-number">4.2.3.</span> <span class="nav-text">Knowledge prepartion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Let-Billboard-Follow-The-Object"><span class="nav-number">4.2.4.</span> <span class="nav-text">Let Billboard Follow The Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Billboard-With-Perspect-View"><span class="nav-number">4.2.5.</span> <span class="nav-text">Billboard With Perspect View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tiled-Sprite-Layer"><span class="nav-number">4.2.6.</span> <span class="nav-text">Tiled Sprite Layer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Show-the-correct-occulusion-of-the-corner"><span class="nav-number">5.</span> <span class="nav-text">Show the correct occulusion of the corner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Future-Improvement"><span class="nav-number">6.</span> <span class="nav-text">Future Improvement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">7.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  



        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tasiYokan</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
      
  <div class="expand-toc">
    <i class="fa fa-list-ol"></i>
    
  </div>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/en/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/en/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/en/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/en/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/en/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/en/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/en/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/en/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/en/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/en/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/en/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/en/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/en/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/en/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
