<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Weekly Animation Share Vol.1</title>
      <link href="/2019/09/07/weekly-animation-share-vol-1/"/>
      <url>/2019/09/07/weekly-animation-share-vol-1/</url>
      
        <content type="html"><![CDATA[<p>作为第一期的每周动画分享（会有几期也不知道…），先简单介绍下做这个系列的动机。之前经常会逛<a href="http://animetaste.net/" target="_blank" rel="noopener">AT! 品赏阿尼墨</a>，通过这个平台看到过不少优秀的作品。但因为网站已经很久没更新了，而如今的动画公众号也缺少一些独立短片的推荐，所以出于个人兴趣爱好，决定（不）定期的更新一些自己发现的有意思的动画短片。这次的三个视频都来自vimeo，由于被墙了，所以国内小伙伴可能看起来不太方便，目前只好提供截图封面，后面我会思考下如何解决这个问题…</p><h1 id="CAT-DAYS-ねこのひ"><a href="#CAT-DAYS-ねこのひ" class="headerlink" title="CAT DAYS / ねこのひ"></a>CAT DAYS / ねこのひ</h1><p><iframe id="iframe-blocked" src="https://player.vimeo.com/video/296302547?color=ef1900&title=0&byline=0&portrait=0" width="640" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen altimgurl="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/weekly-animation-share-vol-1/cat-days.jpg"></iframe></p><p><a href="https://vimeo.com/296302547" target="_blank" rel="noopener">CAT DAYS / ねこ の ひ / Neko no Hi</a> from <a href="https://vimeo.com/user45689947" target="_blank" rel="noopener">Jon Frickey</a></p><p>这一部2018年的动画获得过多个动画节的大奖，讲述的是一个叫Jiro的小男孩在某一天得了一场病。当他爸爸带他去看病的时候，医生带给了他们一个“惊人”的消息，男孩竟然可能是猫。随后的等待最终的鉴定结果的几天里，男孩和爸爸都试图完成这个身份的转变…<br>这部片子很容易让人联想到细田守的动画<a href="http://www.ookamikodomo.jp/index.html" target="_blank" rel="noopener">《狼的孩子雨和雪》(おおかみこどもの雨と雪)</a>，同样是讲述的人的动物化。他们之所以能将生活中本不可能真实发生的事，描绘的非常自然，得益于他们能将身份认同/身份代入这一点用巧妙的方式代入到故事的主体中。人固然是人本身，可是其他动物的天性同样反映在人的身上，尤其是当一个人还是个孩子的时候。通过将人和动物的双重形象进行对比，身份的转变，孩子的成长这一主题得以通过一个更为突出的过程体现了出来。<br>这样一部日系满满的动画，没想到竟然出自一位来自德国的40岁的大叔动画导演<a href="https://www.jonfrickey.com/about" target="_blank" rel="noopener">Jon Frickey</a><br><img src="https://m.media-amazon.com/images/M/MV5BM2Q0N2IzY2ItNWEwYy00NGU3LWIxNTEtM2Y3MDk0Y2ExMjc0XkEyXkFqcGdeQXVyODI5NTk1NzI@._V1_UY317_CR11,0,214,317_AL_.jpg" alt="Jon Frickey"></p><a id="more"></a><h1 id="DOOOOUGH-YEAH"><a href="#DOOOOUGH-YEAH" class="headerlink" title="DOOOOUGH YEAH!"></a>DOOOOUGH YEAH!</h1><p><iframe id="iframe-blocked" src="https://player.vimeo.com/video/236225252?color=ef1900&title=0&byline=0&portrait=0" width="640" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen altimgurl="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/weekly-animation-share-vol-1/doooough-yeah.jpg"></iframe></p><p><a href="https://vimeo.com/236225252" target="_blank" rel="noopener">DOOOOUGH YEAH!</a> from <a href="https://vimeo.com/wesleyfuh" target="_blank" rel="noopener">Wesley Fuh</a></p><p>这是一个有趣的动画短片，讲述的是一个诞生于边角料的瘦小面团，看到其他的面团经过烘焙都成为了“肌肉猛男”(beautiful bread 笑)，迫不及待的想跻身他们的行列，结果机缘巧合之下，变成了椒盐卷饼(brezel)<br>这个动画的亮点在于很有创意。将烤熟的菠萝面包想象成有六块腹肌的健身猛男，而涂上的黄油酱更是成为了耀眼的金光，难怪没有一个面团甘于平庸。幸好结果是正面的，因为它成为了更beautiful的存在（。<br>另外，该片的声效似乎都是作者自己配的，倒是很可爱。最后，大家可能都会记住那一声声的”Dooough Yeah”了吧</p><h1 id="The-Year-of-the-Pig"><a href="#The-Year-of-the-Pig" class="headerlink" title="The Year of the Pig"></a>The Year of the Pig</h1><p><iframe id="iframe-blocked" src="https://player.vimeo.com/video/315958054?color=ef1900&title=0&byline=0&portrait=0" width="640" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen altimgurl="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/weekly-animation-share-vol-1/the-year-of-the-pig.jpg"></iframe></p><p><a href="https://vimeo.com/315958054" target="_blank" rel="noopener">The Year of the Pig</a> from <a href="https://vimeo.com/ryanbooth" target="_blank" rel="noopener">Ryan Booth</a></p><p>这部小短片严格意义上讲并不好分类。从作者的简单介绍中，他也形容它为”just a collection of moments…”。<br>短片记录的是纽约庆祝农历猪年时的场景以及生活中的一些画面，全片平淡却又有让人感动的小细节，宛如一个人在静静的回忆温暖的瞬间。整体的画面经过电影调色，体现出一种冬日里一股温暖的感觉，也颇有中国80,90年代电影的感觉。短片中的相机抖动既是转场的需要，也为画面增加了不少生活的真实感。<br>不同于中国人庆祝新年时惯用的喜庆音乐，全片的背景音乐都非常祥和而安静，让我们这些来自中国的人们感到有些好奇和陌生。新鲜之余，也从中能窥探出不同文化的人们对未来期待的不同表达。<br>带给我类似感受的还有<a href="https://www.imdb.com/title/tt0401711/" target="_blank" rel="noopener">《巴黎，我爱你》(Paris, je taime)</a>，同样没有过于复杂的剧情，更多的是纪录片似的喃喃自语</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Notes on ddx/ddy</title>
      <link href="/2019/08/25/Notes-on-ddx-ddy/"/>
      <url>/2019/08/25/Notes-on-ddx-ddy/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>ddx/ddy用于返回屏幕空间中某一值关于x,y方向上的偏导数。它只可以用于fragment program中，参数必须来自fragment的输入。<br>HLSL对<a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-ddx" target="_blank" rel="noopener">ddx的定义</a>：Returns the partial derivative of the specified value with respect to the screen-space x-coordinate.<br>GLSL中对应的函数为<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/dFdx.xhtml" target="_blank" rel="noopener">dFdx/dFdy</a></p><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>在triangle rasterization阶段，GPU会对多个像素实例同时运行fragment shader。在最细的程度上，它将会通过SIMD同时跑32-64个像素（实例）。在这些像素中，又会被划分成2 * 2的小组（又被称为quad-fragments），所以每个组会有四个相邻的像素，这样SIMD指令就能同时处理屏幕上2 * 2 = 4个像素了。<br>每个像素中的值都来自于vertex program或其他步骤输出之后得到的插值，所以对于这些值来说，在进入到fragment shader之前就完成了计算，这些是可以并行计算得到的。所以在fragment shader中运行ddx(vertexOuput)的时候，就能知道这个插值的变化导数。</p><p>fragment shader之所以能够访问到相邻像素的数据（即SIMD的不同lanes/thread，每个lanes/thread都处理一个像素），是因为GPU利用了(quad) swizzle进行了跨lanes的数据访问<br><img src="https://anteru.net/images/2018/pixel-crosstalk.svg" alt title="来源：[7]"></p><p>对于AMD的GCN，<code>ds_swizzle_b32</code>指令的offset field是留给<code>ds_pattern</code>的。它有两种模式<a href="#ref">[10]</a>：</p><blockquote><ul><li><strong>Quad-permute mode (QDMode)</strong>: Each of the four adjacent lanes can access each other’s data, and the same switch applies to each set of four. The ds_pattern LSBs directly encode the element ID for each lane.</li><li><strong>Bit-masks mode (BitMode)</strong>: This mode enables limited data sharing within 32 consecutive lanes. Each lane applies bitwise logical operations with constants to its lane ID to produce the element ID from which to read. Constants are encoded in ds_pattern .</li></ul></blockquote><p><img src="https://gpuopen.com/wp-content/uploads/2016/08/ds_pattern.png" alt title="对应的图示"><br>QDMode模式会更清晰一点<br><img src="https://gpuopen.com/wp-content/uploads/2016/08/qdmode.png" alt title="一个简单的例子：分别将原来的0,1,2,3位变成2,1,3,3位"><br><img src="https://gpuopen.com/wp-content/uploads/2016/08/ds-swizzle-b32.png" alt title="过程示意图"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="1-计算Lod或各向异性-Anisotropy"><a href="#1-计算Lod或各向异性-Anisotropy" class="headerlink" title="1.计算Lod或各向异性(Anisotropy)"></a>1.计算Lod或各向异性(Anisotropy)</h2><p>因为mipmap level需要计算fragmentInput.uv的导数，即相邻像素之间对应纹素的差距。过程是将屏幕坐标的点映射到uv平面上，然后计算出距离。取出最大的一个距离L，并做$log_2⁡L$。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/ddx/mipmap_lod.png" alt title="计算mipmap level图示，来源：[5]"><br>其含义就是如果uv平面中采样点很稀，相应的du/dx或其他的值就比较大，L也相应的比较大。这种情况说明Minification了，很多纹素就堆在了一个像素里。我们实际上用不到这么多纹素，于是一个很高级别的mipmap(更模糊的）就可以用来节省渲染的负担，也可以避免出现锯齿。<br><img src="https://i.stack.imgur.com/VJEqW.png" alt title="计算uv的偏导的图示，来源：[1]"></p><h2 id="2-计算面法线"><a href="#2-计算面法线" class="headerlink" title="2.计算面法线"></a>2.计算面法线</h2><p>在 FragShader 中，调用<code>ddx(i.position)</code>, 和<code>ddy(i.position)</code>可以求出相邻的2 个像素之间座标的差值，即两个像素在三角面上采样的点所构成的向量。下面图中的红色和绿色2个向量即为ddx,ddy所返回的向量<br><img src="http://album.sina.com.cn/pic/002hBfPnzy7dvLft6NX99" alt title="来源：[2]"></p><p>而这2 个向量都在这个三角形的平面上，那么<br><code>normal = normalize(cross(ddx(pos), ddy(pos)))</code><br>就可以求出的面的法线，但是这里要注意，在 HLSL 或者Unity shader里要写成normalize(cross(ddy(pos), ddx(pos))) , 不然法线是反向的。这个是由于左右手座标系引起的。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>嵌套使用ddx(p)或ddy(p)可能导致undefine的值，如ddx(ddx(p))或ddx(ddy(p))。<br>同时，程序假设参数p是连续的。对于嵌在flow-control代码段的值，因为不是每一个在quad-fragment中的片段都会执行同样的branch，所以结果也是undefine的<br>ddx/ddy分为coarse版本和fine版本。如果直接使用ddx，等价于ddx_coarse（可以看做alias).<br><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/ddx-coarse" target="_blank" rel="noopener">ddx_coarse</a>和<a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/ddx-fine" target="_blank" rel="noopener">ddx_fine</a>对于同一组2*2的quad-fragment的四个像素，他们的偏导数都将会是一样。这两个函数需要Shader Model 5的支持<a href="#ref">[4]</a></p><p>其他相关函数：<code><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-fwidth" target="_blank" rel="noopener">fwidth(p)</a> = abs(ddx(p)) + abs(ddy(p))</code></p><p><span id="ref"></span></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://gamedev.stackexchange.com/a/130933" target="_blank" rel="noopener">[1] What are screen space derivatives and when would I use them?</a><br><a href="http://www.aclockworkberry.com/shader-derivative-functions" target="_blank" rel="noopener">[2] An introduction to shader derivative functions | A Clockwork Berry</a><br><a href="https://gamedev.stackexchange.com/a/62650" target="_blank" rel="noopener">[3] What does ddx (hlsl) actually do?</a><br><a href="https://fgiesen.wordpress.com/2011/07/10/a-trip-through-the-graphics-pipeline-2011-part-8/#comment-1990" target="_blank" rel="noopener">[4] A trip through the Graphics Pipeline 2011, part 8</a><br><a href="http://15462.courses.cs.cmu.edu/spring2018/lecture/persp/slide_055" target="_blank" rel="noopener">[5] [CMU 15462] Lecture 7: PerspectiveTexture</a><br><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading/" target="_blank" rel="noopener">[6] Flat and Wireframe Shading Derivatives and Geometry</a><br><a href="https://anteru.net/blog/2018/more-compute-shaders/" target="_blank" rel="noopener">[7] More compute shaders</a><br><a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter35.html" target="_blank" rel="noopener">[8] [GPU Gems 2] 35.2.4 The Swizzle Operator</a><br><a href="https://developer.nvidia.com/reading-between-threads-shader-intrinsics" target="_blank" rel="noopener">[9] [Reading Between The Threads: Shader Intrinsics] Fragment Quad Swizzle - Data Exchange and Arithmetic</a><br><a href="https://gpuopen.com/amd-gcn-assembly-cross-lane-operations/" target="_blank" rel="noopener">[10] [AMD GCN Assembly: Cross-Lane Operations] The Swizzle Instruction</a></p>]]></content>
      
      
      <categories>
          
          <category> Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作不使用贴图的水滴特效</title>
      <link href="/2019/07/31/raindrop-effect/"/>
      <url>/2019/07/31/raindrop-effect/</url>
      
        <content type="html"><![CDATA[<p>Sorry, currently unavailable</p>]]></content>
      
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从像素之间谈起：像素游戏的画面增强（下）</title>
      <link href="/2017/07/03/from_pixel_to_screen_2/"/>
      <url>/2017/07/03/from_pixel_to_screen_2/</url>
      
        <content type="html"><![CDATA[<p>上篇见 <a href="/2017/07/02/from_pixel_to_screen_1/">从像素之间谈起：像素游戏的画面增强（上）</a></p><h1 id="其他可能的改进"><a href="#其他可能的改进" class="headerlink" title="其他可能的改进"></a>其他可能的改进</h1><h2 id="投影增强"><a href="#投影增强" class="headerlink" title="投影增强"></a>投影增强</h2><p>前面我们在进行扩散投影模拟的时候，是同时对周围八个点进行采样，但是事实上，有时为了控制投影的方向，可以只对一侧的点进行采样<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/sample_weight_partial.png" alt title><br><a id="more"></a><br>如图所示，只需要对右下角的五个格子采样，就可以模拟出左上角的光照。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/unilateral_sample.png" alt title><br>这样造成的效果是亮的部分会凸起，暗的部分会产生凹陷的效果<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/darkness_offset.png" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/lightness_offset.png" alt title></p><h2 id="函数的拟合"><a href="#函数的拟合" class="headerlink" title="函数的拟合"></a>函数的拟合</h2><p>前面在计算相邻点的加权颜色值时，用到了一个指数函数。指数函数的效果的确很好，考虑到在某些平台上exp的消耗可能有点大。另外，任意两个像素之间的欧几里得距离不会超过2.3个像素，所以我们尝试对函数进行一个拟合，如0.926+1.441x + 0.6578x^2 + 0.0417x^4<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/approx_1.jpg" alt title><br>其实我们还可以将把它化成1/(7x^2 +1)，效果也还可以，只是无论是哪种情况，在PC上测试差距并不明显（也有可能适得其反）<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/approx_2.png" alt title></p><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>考虑到有些游戏中，会出现一些因为曝光过度而无法显示扫描线的情况。于是，我们就需要对扫描线进行加强：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> limit = <span class="number">1</span> - step(<span class="number">257.0</span>, min(frac(i.pixel_no.x), <span class="number">1</span>- frac(i.pixel_no.y)) * _MainTex_TexelSize.z);</span><br><span class="line"><span class="keyword">float</span> bright = Luminance(out_color);</span><br><span class="line"><span class="keyword">return</span> fixed4(out_color *(<span class="number">1.8</span> - limit * bright * bright * <span class="number">0.89</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure></p><p>但是对于某些偏暗的游戏，如果为了提高整体亮度，而扫描线同时也强化的很厉害，那么就会导致“碳化”<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/Overexposed.png" alt title="中间的白色由于亮度过高，在补偿的时候会显得非常暗"><br>虽然这样的扫描线加强在其他场合正是我们需要的，但在这里只会让画面变得很脏。关于这个问题并没有很好的解决方案，这需要根据不同游戏对参数做出调整。作为游戏开发，如果美术风格及早的确定，颜色的选择有所参照，将会对程序的优化有极大的帮助。而2D像素游戏由于很少受光照影响，再加上像素画本身也极其依赖于palette，所以如果palette控制的好，是可以根据其调试出一个很好的状态的。</p><p>由于目前只用针对一款游戏，所以上面的手工调整可以接受。如果我们需要大量的调整，我在想，可能还有一种思路是像tone mapping一样，将亮度映射在一个合理的区域内，这样既保留了细节又处理了边界状况。</p><h2 id="Tactics-Ogre的特殊处理"><a href="#Tactics-Ogre的特殊处理" class="headerlink" title="Tactics Ogre的特殊处理"></a>Tactics Ogre的特殊处理</h2><p>刚开始我为Taactic Ogre（中文译为：皇家骑士团）写shader的时候，出现了一个问题。由于很容易知道psp的分辨率是480*272，我就将其硬编码到shader中。但是却出现了一些意想不到的状况。在横坐标方向上，扫描线的分布不均匀。由于是周期性的，并且随着窗口的扩大问题更为严重，我最开始猜测是模拟器的精度出现了问题，我查了下changelog也的确提到了这个问题，只是我使用的版本应该已经修复了这个问题。另外，我测试了其他的游戏，发现一切都很正常，如果真的是精度问题，不该只出现在这一款游戏上。查看了整个render过程后发现Tactics Ogre中有些地方与其他游戏做的不同，比如<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/ToScreen5.png" alt title="注意纹理右侧的黑边"><br>Tactics Ogre在draw顶部的滚动文本时，并不会对其裁剪，而是放到了第二个color pass里才进行裁剪<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/psp_firstpass_cut.png" alt title><br>不过ppsspp模拟器提供了u_texelDelta这样一个uniform，我们可以利用它得知当前输入纹理的resolution：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec2 c_resolution = <span class="number">1.0f</span> / u_texelDelta;</span><br></pre></td></tr></table></figure></p><p>这样，即使在某些场景中，屏幕的分辨率发生变化，我们也能够保证显示正确的扫描线。<br><br></p><h1 id="最终PSP模拟器效果图"><a href="#最终PSP模拟器效果图" class="headerlink" title="最终PSP模拟器效果图"></a>最终PSP模拟器效果图</h1><p>在这里给出自己制作的在PSP模拟器上的最终效果，请放大后观察<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/zipped_To1.png" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/zipped_To2.jpg" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/zipped_To3.jpg" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/zipped_To4.jpg" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/zipped_To5.jpg" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/zipped_To6.jpg" alt title><br><br></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文主要讨论了针对细像素游戏的画质增强，但是这并不意味着像素游戏的增强方式只有一种，相反，光是<a href="http://filthypants.blogspot.jp/2015/04/more-crt-shaders.html" target="_blank" rel="noopener">这里</a> 就提到多种后期特效。我们也无法说哪种效果比另一种更好。更多的时候，还是需要根据对游戏的定位来定制自己的后期特效，从而让画面为游戏核心服务。程序和美术之间的沟通是否充分也是能否有效的构建出成功的游戏画面中很重要的一个因素。</p><p>最后，你们觉得这是一篇讨论像素游戏中画面增强的文章吗？<br>不，不是的，我只是在安利Tactics Ogre :P</p><p>另：为防止图床炸裂，请勿随意转载:)</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> shader </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从像素之间谈起：像素游戏的画面增强（上）</title>
      <link href="/2017/07/02/from_pixel_to_screen_1/"/>
      <url>/2017/07/02/from_pixel_to_screen_1/</url>
      
        <content type="html"><![CDATA[<p>由于文章太长，我将最初的文章拆成两个部分，下篇见 <a href="/2017/07/03/from_pixel_to_screen_2/">从像素之间谈起：像素游戏的画面增强（下）</a></p><h1 id="无所不在的像素画"><a href="#无所不在的像素画" class="headerlink" title="无所不在的像素画"></a>无所不在的像素画</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>随着分辨率的普遍提高，我们已经告别了依赖于简陋像素来表现游戏画面的年代。但还是有不少人像我一样沉迷于像素美术和游戏。如今到处可以都可以看到的各式像素作品，虽然大多被直接称呼为像素画，但实际上已经分化为很多分支，简单的将其归类为像素作品未免太含糊。在开始正文之前我先将他们粗粗的分个类。一些比较常见的代表如：</p><ol><li>大颗粒像素，此类像素作品一般细节较少，人物符号化或者抽象化。同时还可能出现非像素元素，如光晕，渐变 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/large_scale_pixel.jpg" alt title="单键Bob，一个颇为爽快的flash游戏"><a id="more"></a></li><li><p>粒度较小的像素画，主要还是色块化，边缘并没有强化。 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/dragon_den.gif" alt title="HGSS中的Dragon Den"></p></li><li><p>强化边缘和高光，细节丰富，但是普遍尺寸较小。 <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/small_scale_pixel.png" alt title="Drill Dozer截图"></p></li></ol><p>另外，在一些UI图标的绘制过程中，由于图标较小，也同样采用像素点绘的方式。因为它平时也不会被称为像素画，所以这里也不讨论。</p><p>其中第3种是我在本文中将着重讨论的。<br>这类像素图可能和平时所提到的像素图差的最远，因为它并不是为了做出像素化效果而诞生的。相反它是游戏机在分辨率和色板支持加强之后的产物（光是从GB到GBC，支持的色深就从2位变成了15位）。在这方面，任天堂算是是做到了极致（也可能因为任天堂的主机的屏幕天生小的缘故）这类像素画在抗锯齿（伪），光照，色彩的调和的方面很有特点（这篇文章中不细说）</p><h2 id="再现像素画"><a href="#再现像素画" class="headerlink" title="再现像素画"></a>再现像素画</h2><p>就GBA而言，分辨率为240 *160，但我们现在再制作像素的游戏时，玩家一定不会接受在这么小的一个屏幕上去玩游戏。一个是因为眼睛看的太累（长大后眼睛都变差了…）。另一方面，考虑到像素画的成本，也不建议针对一个1080p的屏幕进行逐像素绘画。为了满足一些玩家想要的像素的效果，一个最简单直接的方法就是将画面放大。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/small_scale_pixel_zoomed.png" alt title="这幅图放大了3倍之后，也许会更容易于将它认为是像素画风"></p><p>虽然这种方法省时省力，但是也会带来一个问题。在绘制像素画中的曲线时，由于一般不对线条使用反走样（会让画面变脏）来抗锯齿。在分辨率较低的时候，像素的边缘可以帮助人们识别且很难注意到异样，但当画面放大后，这些边缘就会显得粗糙不堪。这也是像素画风被一些人所诟病的原因。</p><p>为此，包括ppsspp在内的模拟器中，会内置不少shader来对图像进行后期处理。对于2D图像来说，具体方法包括xBRZ等滤镜来平滑放大图像（xBRZ对2D像素放大会产生平滑而舒适的效果，但是这会损失像素的特征），增加crt, 扫描线等后期特效将像素画做旧。当然，你也可以利用物理的手段将信号输出到CRT屏幕上，参考<a href="http://wavebeam.blogspot.jp/2016/01/a-beginners-guide-to-best-retro-gaming.html" target="_blank" rel="noopener">这里</a><br>另外，<a href="https://blz.la/rgb/gaming_crt.html" target="_blank" rel="noopener">这篇文章</a> 中讲述了一些crt效果的来源，也讨论了很多细节问题。一个简单的对比图： <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/metal_slug.jpg" alt title="from: http://www.neogaf.com/forum/showthread.php?p=236239524"><br>常见的效果如下<br><img src="http://i58.tinypic.com/2lnu2b9.png" alt="尝试翻墙显示" title="from: http://shmups.system11.org/viewtopic.php?f=6&t=51298&start=30" width="50%"><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/geom.jpg" alt title="注意屏幕的扭曲，这其实是crt的物理性质决定的"><br><img src="http://abload.de/img/royale0iu4f.png" alt="尝试翻墙显示" title="注意像素的膨胀" width="50%"></p><p>虽然实现方法不同，但总的来说都是在像素之间增加了隔断，人们的大脑会趋向为这种断裂解释理由，自动为图像进行内部平滑处理。这就和我们凑近屏幕看游戏画面但是不会觉得画面模糊的原因类似。另一方面，因为扫描线的存在，画面的层次感也可以体现出来，使得画面更加可信。甚至连Her Story中都为了剧情的需要用些crt效果。<br><a href="http://filthypants.blogspot.jp/2015/04/more-crt-shaders.html" target="_blank" rel="noopener">这篇文章</a>里介绍了大量的post processing shader，很有借鉴意义。<br><br></p><h1 id="一个shader的实现思路"><a href="#一个shader的实现思路" class="headerlink" title="一个shader的实现思路"></a>一个shader的实现思路</h1><p>本文的后期特效将主要适用于前面所述的第三种情况，也即通过临近采样的方式放大图像而达到加强像素化的目的。更多的模拟LCD屏幕而不是CRT屏幕，所以一些包括屏幕扭曲，通道分离的效果在本文中将不会涉及。本文会利用psp模拟器，将扫描线效果应用到Tactics Ogres（中文译为：皇家骑士团）上。<br>我主要从两方面完成对像素图的画面增强：1.利用微小的分割线来分隔开像素，让人们产生像素相连的错局。2.利用低通滤波器稍许的平滑像素边界（但是不宜平滑太多，不然会失去像素风格的特点）</p><p>为了统一，后面的演示代码都用CG来写，输入的纹理尺寸为512 x 384</p><h2 id="格子的分割"><a href="#格子的分割" class="headerlink" title="格子的分割"></a>格子的分割</h2><h3 id="硬分割"><a href="#硬分割" class="headerlink" title="硬分割"></a>硬分割</h3><p>首先，将像素放大了2倍之后，实际看到的一个“像素 pixel”（叫纹素 texel更为贴切）是2 x 2个像素。虽然我们想营造出的效果是让玩家觉得游戏的像素与像素之间产生了间距，但除了在原先的一个像素上通过勾画边缘来实现分割，我们并不能真的将像素之间创造出空格。这步操作之后，最小单位仍然是像素。下图所示的分别是每2个像素进行一次分割和每4个像素进行一次分割的图示。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/hard_separate_1.png" alt title="每两格有一个明暗变化周期"><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/hard_separate_2.png" alt title="每四格有一个明暗变化周期"><br>对于后期特效来说，输入的纹理为camera input，上图是1 texel对应 4 pixel，而下面是1 texel对应 16 pixel。<br>为了找到分割的位置，需要能够区分一个纹素所对应的像素。方法并不复杂, 若一个纹素拆分为4*4个像素，可以在顶点着色器上输出如下vec2：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.pixel_no = float2(o.uv.x * _MainTex_TexelSize.z, o.uv.y * _MainTex_TexelSize.w) * <span class="number">0.25</span>;</span><br></pre></td></tr></table></figure></p><p><code>_MainTex_TexelSize</code> 是内置uniform，记录输入纹理的相关信息，其中zw分量即为宽和高。对于ppsspp模拟器，可以通过 <code>u_texelDelta</code> 来计算屏幕的resolution，后面会提到。<br>有了pixel_no的信息，我们就可以在片段着色器里进行插值了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">Pass_Scanline</span><span class="params">(float2 uv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> column = <span class="number">4</span>;</span><br><span class="line">        float2 pixel_no = </span><br><span class="line">            frac(float2(uv.x * <span class="number">1024.0</span>, uv.y * <span class="number">768</span>) * _ScreenScale / column);</span><br><span class="line">        <span class="keyword">if</span>(pixel_no.x &lt; <span class="number">1</span> / column || pixel_no.y &lt; <span class="number">1</span> / column)</span><br><span class="line">            <span class="keyword">return</span> PREVIOUS_PASS(uv) * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> PREVIOUS_PASS(uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中PREVIOUS_PASS是一个宏，用来嵌套伪multi-pass，这里的PREVIOUS_PASS可以简单的理解为上一个获取纹理的值的pass。这里当column为4的时候，一个纹素对应的四个像素的pixel_no的x分量分别为1/8, 3/8, 5/8, 7/8，我们可以利用这个信息来判断究竟哪个像素是这个纹素的边缘。<br>硬分割虽然完成了对像素的分割，但是效果比较生硬。玩家感受到的不是从屏幕上反映的图像，而更像是罩上了网格的图像。这也和asset store上的<a href="https://www.assetstore.unity3d.com/en/#!/content/73708" target="_blank" rel="noopener">这个效果</a>类似。</p><h3 id="丰富分割细节"><a href="#丰富分割细节" class="headerlink" title="丰富分割细节"></a>丰富分割细节</h3><p>硬分割的效果不理想，于是很自然的想到为这个边缘添加一些过渡效果是否会好一点呢？答案是肯定的。另外，为了能取得比较好的过渡效果，我们应该适当提高pixel对texel的比例，测试下来发现一般来说3比较合适，2的话太窄，而4的话，图像放大的过大。<br>为了理解方便，我们将图像的边缘定义为暗，图像的中央定义为亮，这样明暗间隔就能产生所谓的扫面线。问题演变为在一个纹素所对应的所有像素中，如何找到一个亮与暗的分布，从而表现出一个荧光格子的效果<br>如果单纯的亮度从中心开始，依照切比雪夫距离向边缘递减，效果其实不太理想，纹素与纹素之间割裂的依旧生硬<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/cos_sum_tween.png" alt title><br>所以我们想找到一种方式柔滑这一过程，首先可以尝试用高斯平滑来处理<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/gaussian_smooth.png" alt title="不过作用效果还是在一个纹素内，所以还是不够好"></p><p>卷积核<br>简单的过渡不够，所以需要找到一个卷积核（kernel）来将像素周围的情况考虑进去，最常见的低通滤波器就是高斯滤波器（Gaussian Filter）但直接使用的话，会造成画面均匀平滑。Themaister提供了一个很好的思路（虽然由于git目录失效，原始的代码已经不可考，但是我还是在网上找到了一个<a href="https://searchcode.com/codesearch/view/26809099/" target="_blank" rel="noopener">GLSL版本</a> ），效果如下图所示：<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/dotnbloombig.png" alt title="除了有些恼人的小黑边，但是总体效果非常接近我想要的最终效果"><br>他的思路简单概述起来就是，一组像素（如4x4）向所在纹素的相邻8个纹素取样，权重为该像素到纹素距离倒数的负相关。本质上是一个非对称的低通滤波器。它的优势在于，针对每个纹素内的像素，所采样的纹素是一致的（保留了像素的质感）而在纹素内部，利用非对称的卷积核实现亮度的变化。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/9pixel_neighbours.png" alt title="一个纹素被分为9个像素"><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/sample_weight.png" alt title="取左上角的像素进行演示，红色的线条的长度与权重成负相关"><br>我们知道越靠近中间，加权值越高，对于一个靠左下角的像素来说，将其卷积核画出来可能会像这样：<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/euclid_kernel_squared.jpg" alt title="权重为Exp(-2.05 * 平方欧氏距离)"><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/euclid_kernel.jpg" alt title="权重为Exp(-2.05 * 欧氏距离)"><br>之所以不选择平方欧氏距离，是因为这会造成加权之后，中间亮度区分不开来，而周围的亮度又太低，会有种硬分割的感觉。<br>在对周围的采样做了积分之后可以得到下图。虽然和前面的图很像，这张图的意义和刚才的并不一样，它代表的是一个纹素内的亮度分布（假设亮度的原始分布均匀）。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/low-pass_filtering.jpg" alt title><br>考虑到以上的操作局限在一个很小的范围内，所以我们可以将其离散化后观察<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/after_discretization.jpg" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/top_view_discretization.jpg" alt title="从顶部看会更直观"></p><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><h4 id="滤波器的构成"><a href="#滤波器的构成" class="headerlink" title="滤波器的构成"></a>滤波器的构成</h4><p>Themaister的方法中，考虑了亮度对像素最终颜色的影响，这个滤波器由两个函数构成，一个是空间域上的滤波器系数，另一个是值域（亮度）上的系数。如果采样点上的亮度越亮，意味着它将会更多的侵蚀着其他的像素。有关Glow效果，可以参考<a href="http://www.gamasutra.com/view/feature/130520/realtime_glow.php" target="_blank" rel="noopener">这篇文章</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">color_bloom</span><span class="params">(float3 color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// const float3 gray_coeff = float3(0.30, 0.59, 0.11);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> shine = <span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">float</span> bright = Luminance(color);<span class="comment">//dot(color, gray_coeff);</span></span><br><span class="line">    <span class="keyword">return</span> lerp(<span class="number">1.0</span> + shine * <span class="number">0.5</span>, <span class="number">1.0</span> - shine, bright);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们除了可以自己定义gray_coeff以外，我们也可以使用unity中的内置函数，它对应的 <code>gray_coeff</code> 为fixed3(0.22, 0.707, 0.071)<br>另外，通过在lerp的时候增加一个系数，我将暗部的亮度稍微提高了下，弥补曝光不足的情况。</p><h4 id="No-的偏移"><a href="#No-的偏移" class="headerlink" title="No.的偏移"></a>No.的偏移</h4><p>刚才的卷积核只是一个理想状态的演示，实际上，由于任意两个纹素是相邻的，所以只能在一个纹素的两边（看成一个正方形）上进行边的绘制。否则，两个相邻纹素在交界处都绘上黑边会导致扫描线过粗。另外，如果直接采样，将会出现平顶的情况，也即是当边上为偶数个像素的时候，中间会出现高度一样的状况。于是需要对之前的pixel_no进行偏移，偏移之后将会打破原有的平衡，找到一个新的中心。这里的偏移值应该小于1/(column * 2)，否则循环周期将会出问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> delta = dist(frac(pixel_no + float2(<span class="number">-0.125</span>, <span class="number">0.125</span>)), offset + float2(<span class="number">0.5</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure></p> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/before_offset.jpg" alt title> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/after_offset.jpg" alt title><p>通过对比可以看出，偏移之后，左侧和上侧的亮度明显变暗，亮度会表现的更集中在中间的一个点。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/different_subdivision_level.png" alt title="图所示为不同粒度下的表现"></p><h4 id="采样的偏移"><a href="#采样的偏移" class="headerlink" title="采样的偏移"></a>采样的偏移</h4><p>为了给物体增加一些投影，特别是文字，会对当前像素点的周围采样。我们并不是直接用相邻像素采样（相邻像素很有可能来自于同一纹素，所以采样没有意义），而是偏移一段距离，这和ps中的投影是一个原理。只是这里需要特别注意一个问题，也即是之前看到的一张图中出现的黑边问题。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/dotnbloombig.png" alt title="注意人物轮廓周围的小黑边"><br>这个问题的起因是：如果采样点之间始终距离为一个纹素的时，虽然能保证取到的都是周围的纹素，但当图像中文本的边界正好是处于格子的边缘（也就是亮度最低的位置）在经历一个周期后，亮度是最低的地方（周期性所致）就会对之前还在暗色边界范围内的像素采样，这样就会出现在一个白的背景上出现了一条黑边。<br>解决方法就是将采样偏移限制在纹素所包含的像素个数之内，虽然这意味着我们的投影无法超过一个纹素，但是起码会避免一些比较糟糕的情况。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/problem_of_blackline.png" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/problem_of_blackline_solved.png" alt title></p><h4 id="欧氏距离与曼哈顿距离的选择"><a href="#欧氏距离与曼哈顿距离的选择" class="headerlink" title="欧氏距离与曼哈顿距离的选择"></a>欧氏距离与曼哈顿距离的选择</h4><p>前面在谈到权重的时候，我们的图示标注出来的是欧几里得距离，那么如果为了将指令减少几条，变成曼哈顿距离如何呢？结果是：并不好<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/euclid_dist.jpg" alt title="可以看出，形成了一个明显的十字亮斑，并且高度差异并区分度不高"><br>另外值得一提的是，由于编译器和显卡的优化，使用曼哈顿距离并不能节省什么开销。<br><br></p><h2 id="增加bloom"><a href="#增加bloom" class="headerlink" title="增加bloom"></a>增加bloom</h2><p>Bloom能起到加光晕的效果，能进一步降低粗糙感。通常来说，bloom只是作为HDR的一环，过程还可以包括Tone Mapping、Bright Pass Filter以及Blur。但由于我们这里只考虑2D的情况，更多时候HDR可以由美术手工实现，所以我们先不讨论ToneMapping而简单实现Bright和Blur。</p><p>1    混合横向的bloom和纵向的bloom<br>比较常见的bloom中的blur过程分为两次，一次横向像素上的模糊，一次纵向像素上的模糊，两次叠加。但是我们为了省力，也可以在一个pass中进行，毕竟我们只是为了虚化边缘，制造投影的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">Pass_SimpleBloom</span><span class="params">(float2 uv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float4 sum = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    float4 bum = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    float2 glareSize = float2(<span class="number">1.0</span> / <span class="number">512</span>, <span class="number">1.0</span> / <span class="number">384</span>) * <span class="number">0.65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = -width; i &lt; width; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = -height; j &lt; height; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += tex2D(_MainTex, uv + float2(i, j) * glareSize);</span><br><span class="line">            bum += tex2D(_MainTex, uv + float2(j, i) * glareSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 color = PREVIOUS_PASS(uv);</span><br><span class="line">    color = (sum*sum*<span class="number">0.001</span> + bum*bum*<span class="number">0.0080</span>) * _Amount / ((<span class="number">2</span>* height +<span class="number">1</span>) *(<span class="number">2</span>* width +<span class="number">1</span>)) + color*_Power;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="renderTexture与multipass"><a href="#renderTexture与multipass" class="headerlink" title="renderTexture与multipass"></a>renderTexture与multipass</h3><p>Bloom的操作我并没有在ppsspp模拟器中实施，主要原因是我不知道如何在ppsspp中实现真正的multi-pass shader，如果只是通过宏将pass折叠起来，由于bloom需要对周围采样，将会导致计算量指数式上涨。<br>但是这一切在unity中就很容易解决了，只需要在第一遍的pass中将bloom后的输出输出到render texture就可以被后面的shader所利用，两者加起来的时间测试下来大概只有single-pass的1/5，优化效果还是非常明显的。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RenderTexture rtTemp = RenderTexture.GetTemporary(src.width, src.height);</span><br><span class="line">Graphics.Blit(src, rtTemp, _Material_1);</span><br><span class="line">Graphics.Blit(rtTemp, dst, _Material_2);</span><br><span class="line">RenderTexture.ReleaseTemporary(rtTemp);</span><br></pre></td></tr></table></figure></p> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/performance_single.png" alt title="优化之前几乎所有的时间都耗在了最后一个drawIndexed上"> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/performance.png" alt title><p>可以看出分割出两个pass之后开销一下平衡很多。另外，unity中在利用RenderTexture.GetTemporary时，内部会调用<a href="https://docs.unity3d.com/ScriptReference/RenderTexture.DiscardContents.html" target="_blank" rel="noopener">DiscardContents</a> ，因而对CPU的效率也有所提升。详情可以参考<a href="https://docs.unity3d.com/ScriptReference/RenderTexture.GetTemporary.html" target="_blank" rel="noopener">官方文档</a>。<br>增加了bloom之后的效果图。<br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/3xScaled.png" alt title><br> <img src="https://imgs-1259535704.cos.ap-guangzhou.myqcloud.com/blog/crt/result.jpg" alt title><br><br></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphics </tag>
            
            <tag> shader </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
